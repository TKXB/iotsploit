#!/usr/bin/python3

import pluggy
import asyncio
import os
from typing import Optional, Any

from sat_toolkit.core.exploit_spec import AsyncExploitResult
from sat_toolkit.core.base_plugin import BasePlugin
from facedancer.devices.keyboard import USBKeyboardDevice
from facedancer import main as facedancer_main
from sat_toolkit.tools.xlogger import xlog

hookimpl = pluggy.HookimplMarker("exploit_mgr")

class SimpleRubberDuckPlugin(BasePlugin):
    """
    A simplified USB rubber duck plugin that types text on a target system.
    Uses Facedancer to emulate a USB keyboard device.
    """
    
    def __init__(self):
        super().__init__({
            'Name': 'Simple Rubber Duck',
            'Description': 'Simple USB keyboard emulator to type commands automatically.',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'RequiresRoot': False,
            'Parameters': {
                'text': {
                    'type': 'str',
                    'required': False,
                    'description': 'Text to type on the target system',
                    'default': 'echo Hello, from Simple Rubber Duck!\nid\nls -la\n'
                },
                'delay_before_typing': {
                    'type': 'int',
                    'required': False,
                    'description': 'Time to wait in seconds before starting to type',
                    'default': 2
                }
            }
        })
        self.device = None
        self.running = False
        self.logger = xlog.get_logger('simple_rubber_duck')

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        self.logger.info("Initializing SimpleRubberDuckPlugin")

    @hookimpl
    def execute(self, target: Optional[Any] = None, parameters: Optional[dict] = None):
        """
        Primary execution method - synchronous version.
        This is the preferred entry point for Celery tasks.
        """
        self.logger.info("Executing SimpleRubberDuckPlugin")
        
        try:
            # Check if we already have a running instance
            if self.running:
                return AsyncExploitResult(False, "An instance is already running", {})
            
            # Get parameters
            parameters = parameters or {}
            text = parameters.get('text', self.info['Parameters']['text']['default'])
            delay_before_typing = parameters.get('delay_before_typing', 
                                              self.info['Parameters']['delay_before_typing']['default'])
            
            # Initialize USB device
            self.logger.info("Initializing USB keyboard device...")
            try:
                self.device = USBKeyboardDevice()
                self.logger.info(f"USB keyboard device initialized")
            except Exception as e:
                self.logger.error(f"Failed to initialize USB keyboard device: {str(e)}")
                return AsyncExploitResult(False, f"Failed to initialize USB keyboard device: {str(e)}", {})
            
            # Set running flag
            self.running = True
            
            # Define our typing coroutine - similar to rubber-ducky.py
            async def type_text():
                self.logger.info(f"Waiting {delay_before_typing} seconds before typing...")
                await asyncio.sleep(delay_before_typing)
                
                self.logger.info(f"Typing text: {text}")
                await self.device.type_string(text)
                
                self.logger.info("Typing complete.")
                return True
            
            try:
                # Use Facedancer's main function directly - this will block until completion
                self.logger.info("Starting Facedancer execution...")
                facedancer_main(self.device, type_text())
                self.logger.info("Facedancer execution completed successfully")
            except Exception as e:
                self.logger.error(f"Error in Facedancer execution: {str(e)}")
                if hasattr(e, '__traceback__'):
                    import traceback
                    self.logger.error(''.join(traceback.format_tb(e.__traceback__)))
                self.running = False
                return AsyncExploitResult(False, f"Facedancer execution failed: {str(e)}", 0.0, {})
            
            # Return success - at this point the operation is complete
            return AsyncExploitResult(True, "SimpleRubberDuck executed successfully", 1.0, {
                "status": "complete",
                "message": "Device has typed all commands"
            })
            
        except Exception as e:
            self.running = False
            self.logger.error(f"Error during SimpleRubberDuck execution: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__)))
            return AsyncExploitResult(False, f"SimpleRubberDuck failed: {str(e)}", 0.0, {})
        finally:
            # Reset the running flag
            self.running = False

    @hookimpl
    def cleanup(self):
        """Clean up resources when plugin execution is finished"""
        self.logger.info("Cleaning up SimpleRubberDuckPlugin")
        
        try:
            # Signal any running operations to stop
            self.running = False
            
            # Disconnect the device if it exists
            if hasattr(self, 'device') and self.device:
                try:
                    self.logger.info("Disconnecting USB keyboard device...")
                    self.device.disconnect()
                    self.logger.info("Keyboard Device disconnected")
                except Exception as e:
                    self.logger.error(f"Error disconnecting device: {str(e)}")
                finally:
                    self.device = None
                
            self.logger.info("Cleanup completed successfully")
            
        except Exception as e:
            self.logger.error(f"Error during cleanup: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__))) 