#!/usr/bin/python3

import pluggy
import asyncio
import os
import sys
from typing import Optional, Any

from sat_toolkit.core.exploit_spec import ExploitResult, AsyncExploitResult
from sat_toolkit.core.base_plugin import BasePlugin
from facedancer.devices.keyboard import USBKeyboardDevice
from facedancer.errors import EndEmulation
from sat_toolkit.tools.xlogger import xlog

hookimpl = pluggy.HookimplMarker("exploit_mgr")

class SimpleRubberDuckPlugin(BasePlugin):
    """
    A simplified USB rubber duck plugin that types text on a target system.
    Uses Facedancer to emulate a USB keyboard device.
    """
    
    def __init__(self):
        super().__init__({
            'Name': 'Simple Rubber Duck',
            'Description': 'Simple USB keyboard emulator to type commands automatically.',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'RequiresRoot': False,
            'Parameters': {
                'text': {
                    'type': 'str',
                    'required': False,
                    'description': 'Text to type on the target system',
                    'default': 'echo Hello, from Simple Rubber Duck!\nid\nls -la\n'
                },
                'delay_before_typing': {
                    'type': 'int',
                    'required': False,
                    'description': 'Time to wait in seconds before starting to type',
                    'default': 2
                },
                'delay_after_typing': {
                    'type': 'int',
                    'required': False,
                    'description': 'Time to wait in seconds after typing completes before ending the emulation',
                    'default': 1
                }
            }
        })
        self.device = None
        self.running = False
        self.logger = xlog.get_logger('simple_rubber_duck')

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        self.logger.info("Initializing SimpleRubberDuckPlugin")

    def custom_facedancer_main(self, device, coroutine):
        """
        Custom implementation of Facedancer's main function that doesn't parse command line arguments.
        This is needed when running inside Django where sys.argv contains Django's arguments.
        """
        self.logger.info("Starting custom Facedancer emulation")
        try:
            # Directly call the device's emulate method with our coroutine
            device.emulate(coroutine)
            self.logger.info("Facedancer emulation completed successfully")
        except EndEmulation as e:
            self.logger.info(f"Facedancer emulation ended: {str(e)}")
        except KeyboardInterrupt:
            self.logger.info("Facedancer emulation interrupted by user")
        except Exception as e:
            raise e

    @hookimpl
    def execute(self, target: Optional[Any] = None, parameters: Optional[dict] = None):
        """
        Primary execution method - synchronous version.
        This is the preferred entry point for Celery tasks.
        """
        self.logger.info("Executing SimpleRubberDuckPlugin")
        
        try:
            # Check if we already have a running instance
            if self.running:
                return ExploitResult(False, "An instance is already running", {})
            
            # Get parameters
            parameters = parameters or {}
            text = parameters.get('text', self.info['Parameters']['text']['default'])
            delay_before_typing = parameters.get('delay_before_typing', 
                                              self.info['Parameters']['delay_before_typing']['default'])
            delay_after_typing = parameters.get('delay_after_typing',
                                             self.info['Parameters']['delay_after_typing']['default'])
            
            # Initialize USB device
            self.logger.info("Initializing USB keyboard device...")
            try:
                self.device = USBKeyboardDevice()
                self.logger.info(f"USB keyboard device initialized")
            except Exception as e:
                self.logger.error(f"Failed to initialize USB keyboard device: {str(e)}")
                return ExploitResult(False, f"Failed to initialize USB keyboard device: {str(e)}", {})
            
            # Set running flag
            self.running = True
            
            # Define our typing coroutine - similar to rubber-ducky.py
            async def type_text():
                self.logger.info(f"Waiting {delay_before_typing} seconds before typing...")
                await asyncio.sleep(delay_before_typing)
                
                self.logger.info(f"Typing text: {text}")
                await self.device.type_string(text)
                
                self.logger.info("Typing complete.")
                
                # Wait a configurable amount of time to ensure all keystrokes are processed
                self.logger.info(f"Waiting {delay_after_typing} seconds for keystrokes to be processed...")
                await asyncio.sleep(delay_after_typing)
                
                # Raise EndEmulation to exit facedancer_main cleanly without requiring Ctrl+C
                self.logger.info("Exiting facedancer emulation...")
                raise EndEmulation("Typing completed successfully")
            
            try:
                # Use our custom Facedancer main function to avoid argument parsing issues
                self.logger.info("Starting Facedancer execution...")
                self.custom_facedancer_main(self.device, type_text())
                self.logger.info("Facedancer execution completed successfully")
            except Exception as e:
                self.logger.error(f"Error in Facedancer execution: {str(e)}")
                if hasattr(e, '__traceback__'):
                    import traceback
                    self.logger.error(''.join(traceback.format_tb(e.__traceback__)))
                self.running = False
                return ExploitResult(False, f"Facedancer execution failed: {str(e)}", {})
            
            # Return success - at this point the operation is complete
            return ExploitResult(True, "SimpleRubberDuck executed successfully", {
                "status": "complete",
                "message": "Device has typed all commands"
            })
            
        except Exception as e:
            self.running = False
            self.logger.error(f"Error during SimpleRubberDuck execution: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__)))
            return ExploitResult(False, f"SimpleRubberDuck failed: {str(e)}", {})
        finally:
            # Reset the running flag
            self.running = False

    @hookimpl
    def cleanup(self):
        """Clean up resources when plugin execution is finished"""
        self.logger.info("Cleaning up SimpleRubberDuckPlugin")
        
        try:
            # Signal any running operations to stop
            self.running = False
            
            # Disconnect the device if it exists
            if hasattr(self, 'device') and self.device:
                try:
                    self.logger.info("Disconnecting USB keyboard device...")
                    self.device.disconnect()
                    self.logger.info("Keyboard Device disconnected")
                except Exception as e:
                    self.logger.error(f"Error disconnecting device: {str(e)}")
                finally:
                    self.device = None
                
            self.logger.info("Cleanup completed successfully")
            
        except Exception as e:
            self.logger.error(f"Error during cleanup: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__))) 