#!/usr/bin/python3

import pluggy
import asyncio
import os
from typing import Optional, Any

from sat_toolkit.core.exploit_spec import AsyncExploitResult
from sat_toolkit.core.base_plugin import BasePlugin
from facedancer.devices.keyboard import USBKeyboardDevice
from sat_toolkit.tools.xlogger import xlog

hookimpl = pluggy.HookimplMarker("exploit_mgr")

class SimpleRubberDuckPlugin(BasePlugin):
    """
    A simplified USB rubber duck plugin that types text on a target system.
    Uses Facedancer to emulate a USB keyboard device.
    """
    
    def __init__(self):
        super().__init__({
            'Name': 'Simple Rubber Duck',
            'Description': 'Simple USB keyboard emulator to type commands automatically.',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'RequiresRoot': False,
            'Parameters': {
                'text': {
                    'type': 'str',
                    'required': False,
                    'description': 'Text to type on the target system',
                    'default': 'echo Hello, from Simple Rubber Duck!\nid\nls -la\n'
                },
                'delay_before_typing': {
                    'type': 'int',
                    'required': False,
                    'description': 'Time to wait in seconds before starting to type',
                    'default': 2
                }
            }
        })
        self.device = None
        self.running = False
        self.logger = xlog.get_logger('simple_rubber_duck')

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        self.logger.info("Initializing SimpleRubberDuckPlugin")

    def _type_text_sync(self, text, delay_before_typing):
        """Core function to type text using the keyboard device (synchronous version)"""
        try:
            self.logger.info("Connecting USB keyboard device...")
            self.device.connect()
            self.logger.info("USB device connected successfully!")
            
            # Create a new event loop just for the typing operations
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            # Define the async typing function
            async def _type_async():
                # Wait before starting to type
                self.logger.info(f"Waiting {delay_before_typing} seconds before typing...")
                await asyncio.sleep(delay_before_typing)
                
                # Type the text line by line
                lines = text.splitlines()
                total_lines = len(lines)
                
                for i, line in enumerate(lines):
                    if not self.running:
                        self.logger.info("Typing interrupted")
                        break
                    
                    try:
                        self.logger.info(f"Typing line {i+1}/{total_lines}: {line}")
                        await self.device.type_string(line)
                        # Add Enter key after each line
                        await self.device.type_scancode(0x28)  # ENTER key
                        await asyncio.sleep(0.1)
                    except Exception as e:
                        self.logger.error(f"Error typing line {i+1}: {str(e)}")
                
                self.logger.info("Typing complete.")
                
                # The initial typing is complete, now just inform the user that they
                # can manually disconnect when ready
                self.logger.info("Device will remain connected until cleanup is called.")
            
            # Run the async typing function in the event loop
            loop.run_until_complete(_type_async())
            loop.close()
            
        except Exception as e:
            self.logger.error(f"Error in keyboard operations: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__)))
        finally:
            self.logger.info("Typing operations completed")

    @hookimpl
    def execute(self, target: Optional[Any] = None, parameters: Optional[dict] = None):
        """
        Primary execution method - synchronous version.
        This is the preferred entry point for Celery tasks.
        """
        self.logger.info("Executing SimpleRubberDuckPlugin")
        
        try:
            # Check if we already have a running instance
            if self.running:
                return AsyncExploitResult(False, "An instance is already running", {})
            
            # Get parameters
            parameters = parameters or {}
            text = parameters.get('text', self.info['Parameters']['text']['default'])
            delay_before_typing = parameters.get('delay_before_typing', 
                                              self.info['Parameters']['delay_before_typing']['default'])
            
            # Initialize USB device
            self.logger.info("Initializing USB keyboard device...")
            try:
                # Check for root privileges on Linux
                try:
                    if os.name == 'posix' and os.geteuid() != 0:
                        self.logger.warning("Not running as root, USB device access may be limited")
                except AttributeError:
                    pass
                
                self.device = USBKeyboardDevice()
                self.logger.info(f"USB keyboard device initialized")
            except Exception as e:
                self.logger.error(f"Failed to initialize USB keyboard device: {str(e)}")
                return AsyncExploitResult(False, f"Failed to initialize USB keyboard device: {str(e)}", {})
            
            # Set running flag
            self.running = True
            
            # Execute the typing operations synchronously
            # Note: This will block until typing is complete, which is fine for Celery
            self._type_text_sync(text, delay_before_typing)
            
            return AsyncExploitResult(True, "SimpleRubberDuck executed successfully", 1.0, {
                "status": "complete",
                "message": "Device has typed all commands"
            })
            
        except Exception as e:
            self.logger.error(f"Error during SimpleRubberDuck execution: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__)))
            return AsyncExploitResult(False, f"SimpleRubberDuck failed: {str(e)}", 0.0, {})

    @hookimpl
    def cleanup(self):
        """Clean up resources when plugin execution is finished"""
        self.logger.info("Cleaning up SimpleRubberDuckPlugin")
        
        try:
            # Signal any running operations to stop
            self.running = False
            
            # Disconnect the device if it exists
            if hasattr(self, 'device') and self.device:
                try:
                    self.logger.info("Disconnecting USB keyboard device...")
                    self.device.disconnect()
                    self.logger.info("Keyboard Device disconnected")
                except Exception as e:
                    self.logger.error(f"Error disconnecting device: {str(e)}")
                finally:
                    self.device = None
                
            self.logger.info("Cleanup completed successfully")
            
        except Exception as e:
            self.logger.error(f"Error during cleanup: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__))) 