#!/usr/bin/python3

import pluggy
import asyncio
import os
import threading
from typing import Optional, Any

from sat_toolkit.core.exploit_spec import AsyncExploitResult
from sat_toolkit.core.base_plugin import BasePlugin
from facedancer.devices.keyboard import USBKeyboardDevice
from sat_toolkit.tools.xlogger import xlog

# Import async_to_sync to handle asyncio with Celery
from asgiref.sync import async_to_sync

hookimpl = pluggy.HookimplMarker("exploit_mgr")

class SimpleRubberDuckPlugin(BasePlugin):
    """
    A simplified USB rubber duck plugin that types text on a target system.
    Uses Facedancer to emulate a USB keyboard device.
    """
    
    def __init__(self):
        super().__init__({
            'Name': 'Simple Rubber Duck',
            'Description': 'Simple USB keyboard emulator to type commands automatically.',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'RequiresRoot': False,
            'Parameters': {
                'text': {
                    'type': 'str',
                    'required': False,
                    'description': 'Text to type on the target system',
                    'default': 'echo Hello, from Simple Rubber Duck!\nid\nls -la\n'
                },
                'delay_before_typing': {
                    'type': 'int',
                    'required': False,
                    'description': 'Time to wait in seconds before starting to type',
                    'default': 2
                }
            }
        })
        self.device = None
        self.running = False
        self.logger = xlog.get_logger('simple_rubber_duck')

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        self.logger.info("Initializing SimpleRubberDuckPlugin")
    
    async def _type_text(self, text, delay_before_typing):
        """Core function to type text using the keyboard device"""
        try:
            self.logger.info("Connecting USB keyboard device...")
            self.device.connect()
            self.logger.info("USB device connected successfully!")
            
            # Wait before starting to type
            self.logger.info(f"Waiting {delay_before_typing} seconds before typing...")
            await asyncio.sleep(delay_before_typing)
            
            # Type the text line by line
            lines = text.splitlines()
            total_lines = len(lines)
            
            for i, line in enumerate(lines):
                if not self.running:
                    self.logger.info("Typing interrupted")
                    break
                
                try:
                    self.logger.info(f"Typing line {i+1}/{total_lines}: {line}")
                    await self.device.type_string(line)
                    # Add Enter key after each line
                    await self.device.type_scancode(0x28)  # ENTER key
                    await asyncio.sleep(0.1)
                except Exception as e:
                    self.logger.error(f"Error typing line {i+1}: {str(e)}")
            
            self.logger.info("Typing complete. Idly handling USB requests.")
            
            # Keep the device running to maintain the connection
            while self.running:
                try:
                    self.device.backend.service_irqs()
                except Exception as e:
                    self.logger.error(f"Error servicing IRQs: {e}")
                    break
                await asyncio.sleep(0.1)
                
        except Exception as e:
            self.logger.error(f"Error in keyboard operations: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__)))
        finally:
            if self.running:
                self.logger.info("Operations complete, keeping device connected")
            else:
                self.logger.info("Operations interrupted, will disconnect device")

    def _keyboard_thread_function(self, text, delay_before_typing):
        """Thread function that handles keyboard operations with its own event loop"""
        try:
            self.logger.info("Starting keyboard thread")
            
            # Create a new event loop for this thread
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            # Run the keyboard operations in this loop
            loop.run_until_complete(self._type_text(text, delay_before_typing))
            
            self.logger.info("Keyboard operations completed")
        except Exception as e:
            self.logger.error(f"Error in keyboard thread: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__)))
        finally:
            if 'loop' in locals() and loop.is_running():
                loop.close()
            self.logger.info("Keyboard thread exited")

    @hookimpl
    def execute(self, target: Optional[Any] = None, parameters: Optional[dict] = None):
        """
        Primary execution method - synchronous version.
        This is the preferred entry point for Celery tasks.
        """
        self.logger.info("Executing SimpleRubberDuckPlugin")
        
        try:
            # Check if we already have a running instance
            if self.running:
                return AsyncExploitResult(False, "An instance is already running", {})
            
            # Get parameters
            parameters = parameters or {}
            text = parameters.get('text', self.info['Parameters']['text']['default'])
            delay_before_typing = parameters.get('delay_before_typing', 
                                              self.info['Parameters']['delay_before_typing']['default'])
            
            # Initialize USB device
            self.logger.info("Initializing USB keyboard device...")
            try:
                # Check for root privileges on Linux
                try:
                    if os.name == 'posix' and os.geteuid() != 0:
                        self.logger.warning("Not running as root, USB device access may be limited")
                except AttributeError:
                    pass
                
                self.device = USBKeyboardDevice()
                self.logger.info(f"USB keyboard device initialized")
            except Exception as e:
                self.logger.error(f"Failed to initialize USB keyboard device: {str(e)}")
                return AsyncExploitResult(False, f"Failed to initialize USB keyboard device: {str(e)}", {})
            
            # Set running flag
            self.running = True
            
            # Start a thread for keyboard operations
            # This avoids blocking the main thread and potential event loop conflicts
            thread = threading.Thread(
                target=self._keyboard_thread_function,
                args=(text, delay_before_typing),
                daemon=True,
                name="KeyboardThread"
            )
            thread.start()
            self.worker_thread = thread
            
            return AsyncExploitResult(True, "SimpleRubberDuck running successfully", 0.0, {
                "status": "running",
                "message": "Device is typing commands"
            })
            
        except Exception as e:
            self.logger.error(f"Error during SimpleRubberDuck execution: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__)))
            return AsyncExploitResult(False, f"SimpleRubberDuck failed: {str(e)}", 0.0, {})

    @hookimpl
    def cleanup(self):
        """Clean up resources when plugin execution is finished"""
        self.logger.info("Cleaning up SimpleRubberDuckPlugin")
        
        try:
            # Signal any running operations to stop
            self.running = False
            
            # Wait for thread to terminate gracefully with timeout
            if hasattr(self, 'worker_thread') and self.worker_thread and self.worker_thread.is_alive():
                self.logger.info("Waiting for worker thread to terminate...")
                self.worker_thread.join(timeout=2.0)  # Wait up to 2 seconds
                if self.worker_thread.is_alive():
                    self.logger.warning("Worker thread did not terminate in time")
            
            # Disconnect the device if it exists
            if hasattr(self, 'device') and self.device:
                try:
                    self.logger.info("Disconnecting USB keyboard device...")
                    self.device.disconnect()
                    self.logger.info("Keyboard Device disconnected")
                except Exception as e:
                    self.logger.error(f"Error disconnecting device: {str(e)}")
                finally:
                    self.device = None
                    
            # Clean up thread reference
            if hasattr(self, 'worker_thread'):
                del self.worker_thread
                
            self.logger.info("Cleanup completed successfully")
            
        except Exception as e:
            self.logger.error(f"Error during cleanup: {str(e)}")
            if hasattr(e, '__traceback__'):
                import traceback
                self.logger.error(''.join(traceback.format_tb(e.__traceback__))) 