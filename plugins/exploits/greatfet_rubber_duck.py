#!/usr/bin/python3

import threading
import pluggy
from typing import Optional, Any
import asyncio
import os
import re
from sat_toolkit.core.exploit_spec import AsyncExploitResult
from sat_toolkit.core.base_plugin import BasePlugin
from facedancer.devices.keyboard import USBKeyboardDevice
from facedancer.classes.hid.keyboard import KeyboardModifiers
from sat_toolkit.tools.xlogger import xlog

hookimpl = pluggy.HookimplMarker("exploit_mgr")

class RubberDuckPlugin(BasePlugin):
    def __init__(self):
        super().__init__({
            'Name': 'Rubber Duck',
            'Description': 'Emulates a USB keyboard to type keystrokes automatically (USB Rubber Duck).',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'RequiresRoot': False,
            'Parameters': {
                'payload': {
                    'type': 'str',
                    'required': False,
                    'description': 'Commands to type (each line will be executed as a separate command)',
                    'default': 'echo Hello from Rubber Duck!\nid\nls -la\n'
                },
                'delay_before_typing': {
                    'type': 'int',
                    'required': False,
                    'description': 'Time to wait in seconds before starting to type',
                    'default': 2
                },
                'delay_between_lines': {
                    'type': 'float',
                    'required': False,
                    'description': 'Time to wait in seconds between typing each line',
                    'default': 0.5
                },
                'script_file': {
                    'type': 'str',
                    'required': False,
                    'description': 'Path to a script file containing commands to type',
                    'default': ''
                },
                'payload_format': {
                    'type': 'str',
                    'required': False,
                    'description': 'Format of the payload: "plain" for plain text or "ducky" for DuckyScript format',
                    'default': 'plain'
                },
                'target_os': {
                    'type': 'str',
                    'required': False,
                    'description': 'Target operating system for built-in scripts: "windows", "linux", or "none" for custom script',
                    'default': 'none'
                }
            }
        })
        self.device = None
        self.running = False
        self.logger = xlog.get_logger('rubber_duck')
        
        # Define the path to built-in script files
        self.script_files = {
            'windows': 'plugins/exploits/rubber_duck_scripts/windows_payload.txt',
            'linux': 'plugins/exploits/rubber_duck_scripts/linux_infogather.txt'
        }
        
        # Define special key mappings
        self.special_keys = {
            'CTRL': KeyboardModifiers.MOD_LEFT_CTRL,
            'SHIFT': KeyboardModifiers.MOD_LEFT_SHIFT,
            'ALT': KeyboardModifiers.MOD_LEFT_ALT,
            'GUI': KeyboardModifiers.MOD_LEFT_META,
            'WINDOWS': KeyboardModifiers.MOD_LEFT_META,
            'COMMAND': KeyboardModifiers.MOD_LEFT_META,  # Mac Command key
            'OPTION': KeyboardModifiers.MOD_LEFT_ALT,   # Mac Option key
            'ESC': 0x29,
            'ESCAPE': 0x29,
            'ENTER': 0x28,
            'RETURN': 0x28,
            'TAB': 0x2B,
            'SPACE': 0x2C,
            'BACKSPACE': 0x2A,
            'DELETE': 0x4C,
            'INSERT': 0x49,
            'HOME': 0x4A,
            'END': 0x4D,
            'PAGEUP': 0x4B,
            'PAGEDOWN': 0x4E,
            'UP': 0x52,
            'DOWN': 0x51,
            'LEFT': 0x50,
            'RIGHT': 0x4F,
            'F1': 0x3A,
            'F2': 0x3B,
            'F3': 0x3C,
            'F4': 0x3D,
            'F5': 0x3E,
            'F6': 0x3F,
            'F7': 0x40,
            'F8': 0x41,
            'F9': 0x42,
            'F10': 0x43,
            'F11': 0x44,
            'F12': 0x45,
            'CAPSLOCK': 0x39,
        }

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        self.logger.info("Initializing RubberDuckPlugin")

    async def _parse_ducky_script(self, script):
        """Parse a DuckyScript formatted script into executable commands"""
        commands = []
        delay = 0.5  # Default delay in seconds
        
        for line in script.splitlines():
            line = line.strip()
            if not line or line.startswith('REM'):  # Comment line
                continue
            
            # Handle delay commands
            if line.startswith('DELAY '):
                try:
                    delay_ms = int(line.split(' ', 1)[1])
                    commands.append(('DELAY', delay_ms / 1000))  # Convert to seconds
                except (ValueError, IndexError):
                    self.logger.warning(f"Invalid delay command: {line}")
                continue
            
            # Handle STRING command (regular typing)
            if line.startswith('STRING '):
                text = line[7:]  # Extract text after 'STRING '
                commands.append(('STRING', text))
                continue
            
            # Handle key combinations like "CTRL ALT DELETE"
            parts = line.split()
            if all(part in self.special_keys for part in parts):
                commands.append(('KEYS', parts))
                continue
            
            self.logger.warning(f"Unrecognized DuckyScript command: {line}")
        
        return commands

    async def _execute_special_keys(self, key_combination):
        """Execute a special key combination"""
        modifiers = 0
        keys = []
        
        for key in key_combination:
            if key in ['CTRL', 'SHIFT', 'ALT', 'GUI', 'WINDOWS', 'COMMAND', 'OPTION']:
                modifiers |= self.special_keys[key]
            else:
                keys.append(self.special_keys[key])
        
        if not keys:  # If only modifiers, add a blank key
            keys = [0]
            
        for key in keys:
            # Use type_scancode instead of press_key/release_all_keys
            await self.device.type_scancode(key, modifiers=modifiers, duration=0.05)

    @hookimpl
    async def execute_async(self, target: Optional[Any] = None, parameters: Optional[dict] = None) -> AsyncExploitResult:
        self.logger.info("Executing RubberDuckPlugin asynchronously")
        try:
            self.device = USBKeyboardDevice()
            if not self.device:
                return AsyncExploitResult(False, "Keyboard device not initialized", {})

            # Get parameters
            parameters = parameters or {}
            delay_before_typing = parameters.get('delay_before_typing', 
                                                self.info['Parameters']['delay_before_typing']['default'])
            delay_between_lines = parameters.get('delay_between_lines', 
                                                self.info['Parameters']['delay_between_lines']['default'])
            payload_format = parameters.get('payload_format',
                                           self.info['Parameters']['payload_format']['default'])
            target_os = parameters.get('target_os',
                                      self.info['Parameters']['target_os']['default'])
            
            # Determine payload source (target_os, script_file, or direct payload)
            script_file = parameters.get('script_file', self.info['Parameters']['script_file']['default'])
            
            # If target_os is specified, use the corresponding built-in script
            if target_os != 'none' and target_os in self.script_files:
                script_file = self.script_files[target_os]
                self.logger.info(f"Using built-in {target_os} script: {script_file}")
                # For built-in scripts, automatically set payload format to ducky
                payload_format = 'ducky'
            
            payload = parameters.get('payload', self.info['Parameters']['payload']['default'])
            
            if script_file and os.path.exists(script_file):
                self.logger.info(f"Reading payload from script file: {script_file}")
                try:
                    with open(script_file, 'r') as f:
                        payload = f.read()
                except Exception as e:
                    self.logger.error(f"Error reading script file: {str(e)}")
                    return AsyncExploitResult(False, f"Failed to read script file: {str(e)}", {})
            elif script_file and not os.path.exists(script_file):
                self.logger.error(f"Script file not found: {script_file}")
                return AsyncExploitResult(False, f"Script file not found: {script_file}", {})
            
            # Parse the payload based on format
            if payload_format.lower() == 'ducky':
                self.logger.info("Parsing payload as DuckyScript")
                parsed_commands = await self._parse_ducky_script(payload)
            else:
                # Plain text format - each line is a command to type
                self.logger.info("Using plain text payload format")
                parsed_commands = [('STRING', line) for line in payload.splitlines()]
            
            # Define typing coroutine
            async def type_commands():
                self.logger.info(f"USB keyboard device is active. Will start typing in {delay_before_typing} seconds...")
                
                # Wait before starting to type - removing wait_for_host() call
                # as USBKeyboardDevice doesn't have this method
                await asyncio.sleep(delay_before_typing)
                self.logger.info("Starting to type commands...")
                
                total_commands = len(parsed_commands)
                
                for i, (cmd_type, cmd_data) in enumerate(parsed_commands):
                    if not self.running:
                        break
                    
                    try:
                        if cmd_type == 'DELAY':
                            self.logger.info(f"Waiting for {cmd_data} seconds...")
                            await asyncio.sleep(cmd_data)
                        elif cmd_type == 'STRING':
                            self.logger.info(f"Typing text ({i+1}/{total_commands}): {cmd_data}")
                            await self.device.type_string(cmd_data)
                            # Add enter key at the end of each command line for plain text mode
                            if payload_format.lower() == 'plain':
                                await self.device.type_scancode(0x28)  # ENTER key
                                await asyncio.sleep(0.05)
                        elif cmd_type == 'KEYS':
                            self.logger.info(f"Executing key combination ({i+1}/{total_commands}): {' '.join(cmd_data)}")
                            await self._execute_special_keys(cmd_data)
                    except Exception as e:
                        self.logger.error(f"Error executing command {i+1}: {str(e)}")
                    
                    # Report progress
                    progress = (i + 1) / total_commands
                    yield AsyncExploitResult(
                        True, 
                        f"Executed command {i+1}/{total_commands}", 
                        progress,
                        {"current_command": f"{cmd_type}: {cmd_data}", "progress": progress}
                    )
                    
                    # Wait between commands
                    if i < total_commands - 1:
                        await asyncio.sleep(delay_between_lines)
                
                self.logger.info("Typing complete. Idly handling USB requests.")
                yield AsyncExploitResult(
                    True,
                    "All commands executed successfully",
                    1.0,
                    {"status": "completed"}
                )

            # Start the Facedancer emulation in a new thread to avoid event loop conflict
            self.running = True
            
            def emulate_thread():
                try:
                    # Create a new event loop for this thread
                    thread_loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(thread_loop)
                    
                    # Define the keyboard operation coroutine
                    async def keyboard_operations():
                        # Connect the device
                        self.logger.info("Connecting USB keyboard device...")
                        self.device.connect()
                        
                        # Process typing commands
                        self.logger.info("Running typing commands...")
                        gen = type_commands()
                        while True:
                            try:
                                # Get the next command
                                next_cmd = await gen.__anext__()
                                # Process result if needed
                            except StopAsyncIteration:
                                # Generator is exhausted
                                break
                            except Exception as e:
                                self.logger.error(f"Error processing command: {str(e)}")
                                break
                                
                        # Keep the device running to maintain the connection
                        self.logger.info("Commands completed, keeping device connected...")
                        while self.running:
                            # Just service the device events
                            self.device.backend.service_irqs()
                            await asyncio.sleep(0.1)
                    
                    # Run the coroutine in this thread's event loop
                    thread_loop.run_until_complete(keyboard_operations())
                    
                except Exception as e:
                    self.logger.error(f"Error in emulation thread: {str(e)}")
                    if hasattr(e, '__traceback__'):
                        import traceback
                        self.logger.error(traceback.format_tb(e.__traceback__))
                finally:
                    # Clean up
                    if 'thread_loop' in locals() and thread_loop.is_running():
                        thread_loop.close()

            t = threading.Thread(target=emulate_thread, name="RubberDuckEmulationThread")
            t.daemon = True  # Mark as daemon so it doesn't block process exit
            t.start()

            return AsyncExploitResult(True, "Rubber Duck device running successfully", 0.0, {
                "status": "running",
                "message": "Device is waiting to type commands"
            })

        except Exception as e:
            self.logger.error(f"Error during Rubber Duck execution: {str(e)}")
            return AsyncExploitResult(False, f"Rubber Duck failed: {str(e)}", 0.0, {})

    @hookimpl
    def execute(self, target: Optional[Any] = None, parameters: Optional[dict] = None):
        """
        Synchronous execution method for backward compatibility
        """
        self.logger.info("Executing RubberDuckPlugin synchronously (not recommended)")
        try:
            # Create a simple event loop and run the async method
            loop = asyncio.new_event_loop()
            result = loop.run_until_complete(self.execute_async(target, parameters))
            loop.close()
            return result
        except Exception as e:
            self.logger.error(f"Error during synchronous execution: {str(e)}")
            return AsyncExploitResult(False, f"Synchronous execution failed: {str(e)}", 0.0, {})

    @hookimpl
    def cleanup(self):
        self.logger.info("Cleaning up RubberDuckPlugin")
        try:
            # Signal the thread to stop
            self.running = False
            
            # Wait a moment for the thread to clean up
            import time
            time.sleep(0.5)
            
            # Disconnect the device if it exists
            if self.device:
                try:
                    self.device.disconnect()  # Disconnect the emulated device
                    self.logger.info("Keyboard Device disconnected")
                except Exception as e:
                    self.logger.error(f"Error disconnecting device: {str(e)}")
                finally:
                    self.device = None
                    
        except Exception as e:
            self.logger.error(f"Error during cleanup: {str(e)}") 