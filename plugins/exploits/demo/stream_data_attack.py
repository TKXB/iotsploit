#!/usr/bin/python3

import logging
import pluggy
from typing import Optional, Any
import asyncio
import random
import time
from sat_toolkit.core.exploit_spec import AsyncExploitResult
from sat_toolkit.core.base_plugin import BasePlugin
from sat_toolkit.core.stream_manager import StreamManager, StreamData, StreamType

logger = logging.getLogger(__name__)
hookimpl = pluggy.HookimplMarker("exploit_mgr")

class StreamDataAttackPlugin(BasePlugin):
    def __init__(self):
        super().__init__({
            'Name': 'Stream Data Attack',
            'Description': 'A demo plugin that simulates continuous data streaming from multiple interfaces.',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'Parameters': {
                'duration': {
                    'type': 'int',
                    'required': False,
                    'description': 'Duration in seconds (0 for infinite)',
                    'default': 30,
                    'validation': {
                        'min': 0,
                        'max': 3600
                    }
                },
                'interfaces': {
                    'type': 'list',
                    'required': False,
                    'description': 'List of interfaces to simulate',
                    'default': ['uart', 'can'],
                    'validation': {
                        'choices': ['uart', 'can', 'spi', 'i2c']
                    }
                }
            }
        })
        self._stop_attack = False
        self.stream_manager = StreamManager()
        self.device_id = "stream_attack_device"

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        logger.debug("Initializing StreamDataAttackPlugin")
        self._stop_attack = False

    async def _generate_uart_data(self):
        """Simulate UART data generation"""
        while not self._stop_attack:
            data = bytes([random.randint(0, 255) for _ in range(16)])
            stream_data = StreamData(
                stream_type=StreamType.UART,
                device_id=self.device_id,
                timestamp=time.time(),
                data=data.hex(),
                metadata={
                    "baudrate": 115200,
                    "port": "/dev/ttyUSB0",
                    "parity": "none",
                    "stopbits": 1
                }
            )
            await self.stream_manager.broadcast_data(stream_data)
            await asyncio.sleep(0.1)  # Simulate 10Hz UART data

    async def _generate_can_data(self):
        """Simulate CAN bus data generation"""
        while not self._stop_attack:
            can_id = random.randint(0x100, 0x7FF)
            data = bytes([random.randint(0, 255) for _ in range(8)])
            stream_data = StreamData(
                stream_type=StreamType.CAN,
                device_id=self.device_id,
                timestamp=time.time(),
                data={
                    "can_id": hex(can_id),
                    "data": data.hex(),
                    "is_extended_id": False,
                    "is_remote_frame": False,
                    "is_error_frame": False
                },
                metadata={
                    "bitrate": 500000,
                    "channel": "can0"
                }
            )
            await self.stream_manager.broadcast_data(stream_data)
            await asyncio.sleep(0.05)  # Simulate 20Hz CAN data

    @hookimpl
    async def execute_async(self, target: Optional[Any] = None, parameters: Optional[dict] = None) -> AsyncExploitResult:
        """Asynchronous execution method"""
        logger.info("Executing StreamDataAttackPlugin")
        async_result = AsyncExploitResult()
        
        try:
            # Get parameters
            duration = parameters.get('duration', 30) if parameters else 30
            interfaces = parameters.get('interfaces', ['uart', 'can']) if parameters else ['uart', 'can']
            
            # Create tasks for each interface
            tasks = []
            if 'uart' in interfaces:
                logger.info("Generating UART data")
                tasks.append(self._generate_uart_data())
            if 'can' in interfaces:
                logger.info("Generating CAN data")
                tasks.append(self._generate_can_data())

            if not tasks:
                raise ValueError("No valid interfaces specified")

            # Start all tasks
            async_result.update(
                status=True,
                progress=0,
                message="Starting data streaming...",
                data={"active_interfaces": interfaces}
            )

            # If duration is 0, run indefinitely
            if duration > 0:
                try:
                    # Run for specified duration
                    await asyncio.wait_for(
                        asyncio.gather(*tasks, return_exceptions=True),
                        timeout=duration
                    )
                except asyncio.TimeoutError:
                    pass  # Expected timeout after duration
            else:
                # Run until stopped
                await asyncio.gather(*tasks, return_exceptions=True)

            if self._stop_attack:
                message = "Data streaming stopped by user"
            else:
                message = "Data streaming completed"

            async_result.update(
                status=True,
                progress=100,
                message=message,
                data={"active_interfaces": interfaces}
            )
            
            return async_result
            
        except Exception as e:
            logger.error(f"Error during stream data attack: {str(e)}")
            async_result.update(
                status=False,
                message=f"Attack failed: {str(e)}",
                progress=100
            )
            return async_result
        finally:
            self._stop_attack = True

    @hookimpl
    def stop(self):
        """Stop the running attack"""
        logger.info("Stopping stream data attack")
        self._stop_attack = True

    @hookimpl
    def cleanup(self):
        """Cleanup after attack"""
        logger.info("Cleaning up StreamDataAttackPlugin")
        self._stop_attack = False

