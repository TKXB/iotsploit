#!/usr/bin/python3

import logging
import threading
import pluggy
from typing import Optional, Any
from sat_toolkit.core.exploit_spec import AsyncExploitResult
from sat_toolkit.core.base_plugin import BasePlugin
from facedancer.devices.ftdi import FTDIDevice
import asyncio

logger = logging.getLogger(__name__)
hookimpl = pluggy.HookimplMarker("exploit_mgr")

class FTDIEchoPlugin(BasePlugin):
    def __init__(self):
        super().__init__({
            'Name': 'FTDI Echo',
            'Description': 'Creates a virtual FTDI device that echoes back received data in uppercase.',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'RequiresRoot': False,
            'Parameters': {
                'message': {
                    'type': 'str',
                    'required': False,
                    'description': 'Custom welcome message to display',
                    'default': 'Hello! Welcome to the FTDI demo.\nEnter any text you\'d like, and we\'ll send it back in UPPERCASE.\n'
                }
            }
        })
        self.device = None
        self.running = False

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        logger.info("Initializing FTDIEchoPlugin")

    async def _handle_data_async(self, data):
        """Async version of data handler."""
        try:
            # Convert the data to uppercase...
            uppercase = data.decode('utf-8').upper()
            # Convert line endings...
            uppercase = uppercase.replace('\r', '\n')
            # Transmit the modified data.
            await self.device.transmit_async(uppercase)
        except Exception as e:
            logger.error(f"Error handling data: {str(e)}")

    @hookimpl
    async def execute_async(self, target: Optional[Any] = None, parameters: Optional[dict] = None) -> AsyncExploitResult:
        logger.info("Executing FTDIEchoPlugin asynchronously")
        self.device = FTDIDevice()
        try:
            if not self.device:
                return AsyncExploitResult(False, "FTDI device not initialized", {})

            # Get welcome message
            welcome_msg = (parameters.get('message') 
                           if parameters 
                           else self.info['Parameters']['message']['default'])

            # Define the coroutine that waits for host and sends welcome message.
            async def send_hello():
                logger.info("Waiting for the host to connect.")
                await self.device.wait_for_host()
                logger.info("Host connected!")
                logger.info("Telling the user hello...")
                self.device.transmit("Hello! Welcome to the FTDI demo.\n")
                self.device.transmit("Enter any text you'd like, and we'll send it back in UPPERCASE.\n")
                # Keep the coroutine alive while the device is running.
                while self.running:
                    await asyncio.sleep(0.1)

            # Set the device data handler.
            self.device.handle_serial_data_received = self._handle_data_async
            self.running = True

            # Start the Facedancer emulation in a new thread to avoid the event loop conflict.
            def emulate_thread():
                self.device.emulate(send_hello())

            t = threading.Thread(target=emulate_thread, name="FTDIEmulationThread")
            t.start()

            return AsyncExploitResult(True, "FTDI echo device running successfully", {
                "status": "running",
                "message": "Device is waiting for data to echo"
            })

        except Exception as e:
            logger.error(f"Error during FTDI echo execution: {str(e)}")
            return AsyncExploitResult(False, f"FTDI echo failed: {str(e)}", {})

    @hookimpl
    def cleanup(self):
        logger.info("Cleaning up FTDIEchoPlugin")
        try:
            if self.device:
                self.running = False
                self.device.disconnect()  # Disconnect the emulated device.
                self.device = None
        except Exception as e:
            logger.error(f"Error during cleanup: {str(e)}")