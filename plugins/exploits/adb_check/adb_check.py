#!/usr/bin/python3

import logging
import re
import datetime
import time
import pluggy
import traceback
from sat_toolkit.tools.sat_utils import *
from sat_toolkit.tools.adb_mgr import ADB_Mgr
from sat_toolkit.tools.input_mgr import Input_Mgr
from sat_toolkit.tools.doip_mgr import DoIP_Mgr
from sat_toolkit.core.exploit_spec import ExploitResult
from sat_toolkit.core.base_plugin import BasePlugin
from sat_toolkit.tools.xlogger import xlog
from typing import Optional, Any
from pwnlib.exception import PwnlibException

logger = xlog.get_logger('adb_check')
hookimpl = pluggy.HookimplMarker("exploit_mgr")

# Disable pwnlib's terminal mode to avoid the spinner issues
import pwnlib.term
pwnlib.term.term_mode = False

class AdbSecurityCheckPlugin(BasePlugin):
    def __init__(self):
        super().__init__({
            'Name': 'ADB Security Check',
            'Description': 'Performs security checks on an Android device via ADB',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'Parameters': {
                'device_serial': {
                    'type': 'string',
                    'required': False,
                    'description': 'ADB device serial number',
                    'default': '2fd1f89'
                },
                'check_suid': {
                    'type': 'bool',
                    'required': False,
                    'description': 'Check for SUID binaries',
                    'default': True
                },
                'check_writable': {
                    'type': 'bool',
                    'required': False,
                    'description': 'Check for writable directories',
                    'default': True
                },
                'skip_interactive': {
                    'type': 'bool',
                    'required': False,
                    'description': 'Skip interactive prompts',
                    'default': True
                }
            }
        })

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        logger.info("Initializing ADB Security Check Plugin")

    @hookimpl
    def execute(self, target: Optional[Any] = None, parameters: Optional[dict] = None) -> ExploitResult:
        """Main execution method"""
        logger.info("Executing ADB Security Check Plugin")
        
        # Get parameters or use defaults
        params = parameters if parameters else {}
        device_serial = params.get('device_serial', '2fd1f89')
        check_suid = params.get('check_suid', True)
        check_writable = params.get('check_writable', True)
        skip_interactive = params.get('skip_interactive', True)
        
        try:
            # First check if device is available
            is_connected = self.check_device_available(device_serial)
            if not is_connected:
                return ExploitResult(
                    False, 
                    f"ADB device {device_serial} not available",
                    {"adb_connection": {"connected": False, "message": "Device not connected"}}
                )
            
            # Collect results
            results = {
                "adb_connection": {"connected": True, "message": "ADB device available"}
            }
            
            # Execute checks that don't require interaction
            try:
                results["selinux_status"] = self.check_selinux(device_serial)
            except Exception as e:
                logger.error(f"Error checking SELinux: {str(e)}")
                results["selinux_status"] = {"error": str(e), "message": "Failed to check SELinux status"}
                
            try:
                results["adb_root"] = self.check_adb_root(device_serial)
            except Exception as e:
                logger.error(f"Error checking ADB root: {str(e)}")
                results["adb_root"] = {"error": str(e), "message": "Failed to check ADB root status"}
            
            # Optional checks
            if check_suid:
                try:
                    results["suid_binaries"] = self.check_suid_binaries(device_serial)
                except Exception as e:
                    logger.error(f"Error checking SUID binaries: {str(e)}")
                    results["suid_binaries"] = {"error": str(e), "message": "Failed to check SUID binaries"}
            
            if check_writable:
                try:
                    results["writable_dirs"] = self.check_writable_dirs(device_serial)
                except Exception as e:
                    logger.error(f"Error checking writable directories: {str(e)}")
                    results["writable_dirs"] = {"error": str(e), "message": "Failed to check writable directories"}
                
            return ExploitResult(True, "ADB security checks completed", results)
        except Exception as e:
            logger.error(f"Error during ADB security checks: {str(e)}")
            logger.debug(traceback.format_exc())
            return ExploitResult(False, f"ADB security checks failed: {str(e)}", {})

    def check_device_available(self, device_serial):
        """Simple check if device is in ADB device list"""
        try:
            adb_devices = ADB_Mgr.Instance().list_devices()
            for dev in adb_devices:
                if dev.serial == device_serial:
                    logger.info(f"Device {device_serial} found in ADB device list")
                    return True
            logger.info(f"Device {device_serial} not found in ADB device list")
            return False
        except Exception as e:
            logger.error(f"Error checking device availability: {str(e)}")
            return False

    def check_adb_connection(self, device_serial, should_close=False):
        """Check if ADB is connected and handle enable/disable"""
        isOpenADB = False
        try:
            isOpenADB = ADB_Mgr.Instance().check_connect_status(device_serial)
        except Exception as e:
            logger.error(f"ADB connection check failed: {str(e)}")
            return {"connected": False, "message": f"ADB connection check failed: {str(e)}"}

        if should_close:
            if isOpenADB:
                try:
                    DoIP_Mgr.Instance().closedebug("dhu")
                    try:
                        isOpenADB = ADB_Mgr.Instance().check_connect_status(device_serial)
                    except Exception:
                        isOpenADB = False
                    return {"connected": not isOpenADB, "message": "ADB connection closed successfully"}
                except Exception as e:
                    logger.error(f"Error closing debug mode: {str(e)}")
                    return {"connected": isOpenADB, "message": f"Failed to close debug mode: {str(e)}"}
            return {"connected": True, "message": "ADB already disconnected"}
        else:
            return {"connected": isOpenADB, "message": "ADB connection established" if isOpenADB else "Failed to connect to ADB"}

    def check_selinux(self, device_serial):
        """Check SELinux status"""
        try:
            status = ADB_Mgr.Instance().query_android_selinux_status(device_serial)
            if status is None:
                return {
                    "enforcing": False,
                    "message": "Unable to determine SELinux status",
                    "security_level": "unknown"
                }
            return {
                "enforcing": status, 
                "message": "SELinux is enforcing" if status else "SELinux is permissive or disabled",
                "security_level": "high" if status else "low"
            }
        except Exception as e:
            logger.error(f"Error checking SELinux: {str(e)}")
            raise

    def check_adb_root(self, device_serial, type="adb"):
        """Check ADB root access"""
        try:
            # Simple connection test without waiting for device
            adb_devices = ADB_Mgr.Instance().list_devices()
            device_found = False
            for dev in adb_devices:
                if dev.serial == device_serial:
                    device_found = True
                    break
            
            if not device_found:
                return {"root_access": False, "message": "Device not connected via ADB"}
                
            # Try non-root connection first
            try:
                cmd_result = ADB_Mgr.Instance().shell_cmd(device_serial, "id", False)
                if "uid=0" in cmd_result:
                    return {"root_access": True, "message": "ADB already has root access"}
            except Exception as e:
                logger.debug(f"Non-root shell command failed: {str(e)}")
                
            # Try root connection
            try:
                cmd_result = ADB_Mgr.Instance().shell_cmd(device_serial, "id", True)
                if "uid=0" in cmd_result:
                    return {"root_access": True, "message": "ADB has root access"}
                else:
                    return {"root_access": False, "message": "ADB connected but does not have root access"}
            except Exception as e:
                logger.debug(f"Root shell command failed: {str(e)}")
                return {"root_access": False, "message": "Failed to get root access via ADB"}
                
        except Exception as e:
            logger.error(f"Error checking ADB root: {str(e)}")
            raise

    def check_suid_binaries(self, device_serial):
        """Check for SUID binaries"""
        try:
            result = ADB_Mgr.Instance().query_files_permission_suid(device_serial)
            
            # Handle None result
            if result is None:
                return {
                    "secure": False,
                    "count": 0,
                    "files": [],
                    "message": "Failed to check SUID binaries"
                }
            
            # Process results for better reporting
            suid_files = []
            if result and isinstance(result, list):
                for item in result:
                    suid_files.append({
                        "path": item.get("filepath", ""),
                        "permissions": item.get("rwx", ""),
                        "owner": item.get("owner", ""),
                        "group": item.get("group", ""),
                        "selinux": item.get("sid", "")
                    })
            
            return {
                "secure": len(suid_files) == 0,
                "count": len(suid_files),
                "files": suid_files,
                "message": f"Found {len(suid_files)} SUID binary files"
            }
        except Exception as e:
            logger.error(f"Error checking SUID binaries: {str(e)}")
            raise

    def check_writable_dirs(self, device_serial):
        """Check for world-writable directories"""
        try:
            passselinuxs = ["unlabeled", "vendor_data_file", "vendor_secure_element_vendor_data_file", "zeekr_data_file"]
            dirs = ADB_Mgr.Instance().query_dirs_permission_writable_by_any_user(
                device_serial,
                "/",
                "",
                ["/dev/", "/sys/", "/proc/"],
                passselinuxs
            )
            
            # Handle None result
            if dirs is None:
                return {
                    "secure": False,
                    "count": 0,
                    "directories": [],
                    "message": "Failed to check writable directories"
                }
            
            # Process results for better reporting
            writable_dirs = []
            if dirs and isinstance(dirs, list):
                for item in dirs:
                    writable_dirs.append({
                        "path": item.get("dirpath", ""),
                        "permissions": item.get("rwx", ""),
                        "owner": item.get("owner", ""),
                        "group": item.get("group", ""),
                        "selinux": item.get("sid", "")
                    })
            
            return {
                "secure": len(writable_dirs) == 0,
                "count": len(writable_dirs),
                "directories": writable_dirs,
                "message": f"Found {len(writable_dirs)} world-writable directories"
            }
        except Exception as e:
            logger.error(f"Error checking writable directories: {str(e)}")
            raise

    @hookimpl
    def cleanup(self):
        """Cleanup resources"""
        logger.info("Cleaning up ADB Security Check Plugin")
        try:
            # Ensure any ADB connections are properly closed
            # This is best-effort cleanup - we catch and log any errors
            pass
        except Exception as e:
            logger.error(f"Error during cleanup: {str(e)}")
