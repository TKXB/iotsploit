import logging
import re
import datetime
import time
import pluggy
from sat_toolkit.tools.sat_utils import *
from sat_toolkit.tools.env_mgr import Env_Mgr
from sat_toolkit.tools.adb_mgr import ADB_Mgr
from sat_toolkit.tools.input_mgr import Input_Mgr
from sat_toolkit.tools.doip_mgr import DoIP_Mgr
from sat_toolkit.core.exploit_spec import ExploitResult
from typing import Optional, Any

logger = logging.getLogger(__name__)
hookimpl = pluggy.HookimplMarker("exploit_mgr")

class DhuAdbSecurityPlugin:
    @hookimpl
    def initialize(self):
        logger.info("Initializing DHU ADB Security Plugin")

    @hookimpl
    def execute(self, target: Optional[Any] = None) -> ExploitResult:
        """Main execution method"""
        try:
            results = {
                "adb_connection": self.check_adb_connection(),
                "selinux_status": self.check_selinux(),
                "adb_root": self.check_adb_root(),
                "suid_binaries": self.check_suid_binaries(),
                "writable_dirs": self.check_writable_dirs()
            }
            return ExploitResult(True, "ADB security checks completed successfully", results)
        except Exception as e:
            logger.error(f"Error during ADB security checks: {str(e)}")
            return ExploitResult(False, f"ADB security checks failed: {str(e)}", {})

    def check_adb_connection(self, should_close=False):
        """Check if ADB is connected and handle enable/disable"""
        isOpenADB = False
        try:
            isOpenADB = ADB_Mgr.Instance().check_connect_status(ADB_Mgr.DHU_ADB_SERIAL)
        except SAT_Exception:
            isOpenADB = False

        if should_close:
            if isOpenADB:
                DoIP_Mgr.Instance().closedebug("dhu")
                try:
                    isOpenADB = ADB_Mgr.Instance().check_connect_status(ADB_Mgr.DHU_ADB_SERIAL)
                except SAT_Exception:
                    isOpenADB = False
                return not isOpenADB
            return True
        else:
            if not isOpenADB:
                ret = Input_Mgr.Instance().single_choice("DHU是否已开启调试模式",["是","否"])
                if ret == "否":
                    DoIP_Mgr.Instance().opendebug("dhu")
                Input_Mgr.Instance().confirm("已开启调试模式，请连接USB线，并切换ADB为Device模式。")
                time.sleep(3)
                isOpenADB = ADB_Mgr.Instance().check_connect_status(ADB_Mgr.DHU_ADB_SERIAL)
            return isOpenADB

    def check_selinux(self):
        """Check SELinux status"""
        return ADB_Mgr.Instance().query_android_selinux_status(ADB_Mgr.DHU_ADB_SERIAL)

    def check_adb_root(self, type="adb"):
        """Check ADB root access"""
        normal_result = ADB_Mgr.Instance().connect_dev(ADB_Mgr.DHU_ADB_SERIAL)
        if normal_result is None:
            return False, "车辆未连接adb shell"
            
        if type == "su":
            idresult = ADB_Mgr.Instance().shell_cmd(ADB_Mgr.DHU_ADB_SERIAL,"su;id")
            return False, f"su权限检查结果: {idresult}"
        else:
            root_result = ADB_Mgr.Instance().connect_dev(ADB_Mgr.DHU_ADB_SERIAL, True)
            return root_result is None, None

    def check_suid_binaries(self):
        """Check for SUID binaries"""
        result = ADB_Mgr.Instance().query_files_permission_suid(ADB_Mgr.DHU_ADB_SERIAL)
        return len(result) == 0, result

    def check_writable_dirs(self):
        """Check for world-writable directories"""
        passselinuxs = ["unlabeled","vendor_data_file","vendor_secure_element_vendor_data_file","zeekr_data_file"]
        dirs = ADB_Mgr.Instance().query_dirs_permission_writable_by_any_user(
            ADB_Mgr.DHU_ADB_SERIAL,
            "/",
            "",
            ["/dev/","/sys/","/proc/"],
            passselinuxs
        )
        return len(dirs) == 0, dirs

def register_plugin(pm):
    pm.register(DhuAdbSecurityPlugin())
