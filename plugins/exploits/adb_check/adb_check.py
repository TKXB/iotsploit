#!/usr/bin/python3

import logging
import re
import datetime
import time
import pluggy
from sat_toolkit.tools.sat_utils import *
from sat_toolkit.tools.adb_mgr import ADB_Mgr
from sat_toolkit.tools.input_mgr import Input_Mgr
from sat_toolkit.tools.doip_mgr import DoIP_Mgr
from sat_toolkit.core.exploit_spec import ExploitResult
from sat_toolkit.core.base_plugin import BasePlugin
from sat_toolkit.tools.xlogger import xlog
from typing import Optional, Any

logger = xlog.get_logger('adb_check')
hookimpl = pluggy.HookimplMarker("exploit_mgr")

class AdbSecurityCheckPlugin(BasePlugin):
    def __init__(self):
        super().__init__({
            'Name': 'ADB Security Check',
            'Description': 'Performs security checks on an Android device via ADB',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'Parameters': {
                'device_serial': {
                    'type': 'string',
                    'required': False,
                    'description': 'ADB device serial number',
                    'default': '2fd1f89'
                },
                'check_suid': {
                    'type': 'bool',
                    'required': False,
                    'description': 'Check for SUID binaries',
                    'default': True
                },
                'check_writable': {
                    'type': 'bool',
                    'required': False,
                    'description': 'Check for writable directories',
                    'default': True
                }
            }
        })

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        logger.info("Initializing ADB Security Check Plugin")

    @hookimpl
    def execute(self, target: Optional[Any] = None, parameters: Optional[dict] = None) -> ExploitResult:
        """Main execution method"""
        logger.info("Executing ADB Security Check Plugin")
        
        # Get parameters or use defaults
        params = parameters if parameters else {}
        device_serial = params.get('device_serial', '2fd1f89')
        check_suid = params.get('check_suid', True)
        check_writable = params.get('check_writable', True)
        
        try:
            results = {
                "adb_connection": self.check_adb_connection(device_serial),
                "selinux_status": self.check_selinux(device_serial),
                "adb_root": self.check_adb_root(device_serial)
            }
            
            # Optional checks
            if check_suid:
                results["suid_binaries"] = self.check_suid_binaries(device_serial)
            
            if check_writable:
                results["writable_dirs"] = self.check_writable_dirs(device_serial)
                
            return ExploitResult(True, "ADB security checks completed successfully", results)
        except Exception as e:
            logger.error(f"Error during ADB security checks: {str(e)}")
            return ExploitResult(False, f"ADB security checks failed: {str(e)}", {})

    def check_adb_connection(self, device_serial, should_close=False):
        """Check if ADB is connected and handle enable/disable"""
        isOpenADB = False
        try:
            isOpenADB = ADB_Mgr.Instance().check_connect_status(device_serial)
        except SAT_Exception:
            isOpenADB = False

        if should_close:
            if isOpenADB:
                DoIP_Mgr.Instance().closedebug("dhu")
                try:
                    isOpenADB = ADB_Mgr.Instance().check_connect_status(device_serial)
                except SAT_Exception:
                    isOpenADB = False
                return {"connected": not isOpenADB, "message": "ADB connection closed successfully"}
            return {"connected": True, "message": "ADB already disconnected"}
        else:
            if not isOpenADB:
                ret = Input_Mgr.Instance().single_choice("Is debug mode enabled on the device?",["Yes","No"])
                if ret == "No":
                    DoIP_Mgr.Instance().opendebug("dhu")
                Input_Mgr.Instance().confirm("Debug mode enabled. Please connect USB cable and switch ADB to Device mode.")
                time.sleep(3)
                isOpenADB = ADB_Mgr.Instance().check_connect_status(device_serial)
            return {"connected": isOpenADB, "message": "ADB connection established" if isOpenADB else "Failed to connect to ADB"}

    def check_selinux(self, device_serial):
        """Check SELinux status"""
        status = ADB_Mgr.Instance().query_android_selinux_status(device_serial)
        return {
            "enforcing": status, 
            "message": "SELinux is enforcing" if status else "SELinux is permissive or disabled",
            "security_level": "high" if status else "low"
        }

    def check_adb_root(self, device_serial, type="adb"):
        """Check ADB root access"""
        normal_result = ADB_Mgr.Instance().connect_dev(device_serial)
        if normal_result is None:
            return {"root_access": False, "message": "Device not connected via ADB"}
            
        if type == "su":
            idresult = ADB_Mgr.Instance().shell_cmd(device_serial, "su;id")
            return {"root_access": "uid=0" in idresult, "message": f"su privilege check result: {idresult}"}
        else:
            root_result = ADB_Mgr.Instance().connect_dev(device_serial, True)
            return {
                "root_access": root_result is not None, 
                "message": "ADB has root access" if root_result is not None else "ADB does not have root access"
            }

    def check_suid_binaries(self, device_serial):
        """Check for SUID binaries"""
        result = ADB_Mgr.Instance().query_files_permission_suid(device_serial)
        
        # Process results for better reporting
        suid_files = []
        if result and isinstance(result, list):
            for item in result:
                suid_files.append({
                    "path": item.get("filepath", ""),
                    "permissions": item.get("rwx", ""),
                    "owner": item.get("owner", ""),
                    "group": item.get("group", ""),
                    "selinux": item.get("sid", "")
                })
        
        return {
            "secure": len(suid_files) == 0,
            "count": len(suid_files),
            "files": suid_files,
            "message": f"Found {len(suid_files)} SUID binary files"
        }

    def check_writable_dirs(self, device_serial):
        """Check for world-writable directories"""
        passselinuxs = ["unlabeled", "vendor_data_file", "vendor_secure_element_vendor_data_file", "zeekr_data_file"]
        dirs = ADB_Mgr.Instance().query_dirs_permission_writable_by_any_user(
            device_serial,
            "/",
            "",
            ["/dev/", "/sys/", "/proc/"],
            passselinuxs
        )
        
        # Process results for better reporting
        writable_dirs = []
        if dirs and isinstance(dirs, list):
            for item in dirs:
                writable_dirs.append({
                    "path": item.get("dirpath", ""),
                    "permissions": item.get("rwx", ""),
                    "owner": item.get("owner", ""),
                    "group": item.get("group", ""),
                    "selinux": item.get("sid", "")
                })
        
        return {
            "secure": len(writable_dirs) == 0,
            "count": len(writable_dirs),
            "directories": writable_dirs,
            "message": f"Found {len(writable_dirs)} world-writable directories"
        }

    @hookimpl
    def cleanup(self):
        """Cleanup resources"""
        logger.info("Cleaning up ADB Security Check Plugin")
