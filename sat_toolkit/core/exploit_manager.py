import os
import importlib.util
import pluggy
import logging
from sat_toolkit.config import EXPLOIT_PLUGINS_DIR
from sat_toolkit.core.base_plugin import BasePlugin
from sat_toolkit.models.Plugin_Model import Plugin
from sat_toolkit.models.PluginGroup_Model import PluginGroup
from sat_toolkit.models.PluginGroupTree_Model import PluginGroupTree
import glob
from pathlib import Path

from sat_toolkit.core.exploit_spec import ExploitPluginSpec
logger = logging.getLogger(__name__)

class ExploitPluginManager:
    def __init__(self):
        self.plugins = {}
        self.load_plugins()
        self.pm = pluggy.PluginManager("exploit_mgr")
        self.pm.add_hookspecs(ExploitPluginSpec)
        self.plugin_groups = self.load_plugin_groups()

    def auto_discover_plugins(self, plugins_dir=EXPLOIT_PLUGINS_DIR):
        """
        Automatically discover and register plugins from the plugins directory.
        Also removes database entries for plugins that no longer exist.
        """
        logger.info(f"Starting plugin auto-discovery in {plugins_dir}")
        
        # Keep track of found plugins
        discovered_plugins = set()
        
        # Find all Python files recursively
        plugin_files = glob.glob(f"{plugins_dir}/**/*.py", recursive=True)
        
        for plugin_file in plugin_files:
            try:
                # Skip __init__.py files
                if "__init__.py" in plugin_file:
                    continue
                
                # Get module path relative to project root
                rel_path = os.path.relpath(plugin_file)
                # Convert path to module notation, but keep the full path including the filename
                module_path = rel_path.replace('/', '.').replace('\\', '.').replace('.py', '')
                
                # Load the module to inspect it
                spec = importlib.util.spec_from_file_location(module_path, plugin_file)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Find plugin class that inherits from BasePlugin
                plugin_class = None
                for name, obj in module.__dict__.items():
                    if isinstance(obj, type) and issubclass(obj, BasePlugin) and obj != BasePlugin:
                        plugin_class = obj
                        break
                
                if plugin_class:
                    # Instantiate to get plugin info
                    plugin_instance = plugin_class()
                    plugin_info = plugin_instance.get_info()
                    
                    if plugin_info:
                        plugin_name = plugin_info.get('Name', plugin_class.__name__)
                        # Create or update plugin in database
                        plugin, created = Plugin.objects.update_or_create(
                            name=plugin_name,
                            defaults={
                                'description': plugin_info.get('Description', ''),
                                'enabled': True,
                                'module_path': f"{module_path}.{plugin_class.__name__}",  # Include class name in module path
                                'license': plugin_info.get('License', ''),
                                'author': plugin_info.get('Author', ''),
                                'parameters': str(plugin_info.get('Parameters', {}))
                            }
                        )
                        
                        # Add to discovered plugins set
                        discovered_plugins.add(plugin_name)
                        
                        action = "Created" if created else "Updated"
                        logger.info(f"{action} plugin in database: {plugin_name}")
                
            except Exception as e:
                logger.error(f"Error processing plugin file {plugin_file}: {str(e)}")
                logger.debug("Detailed error:", exc_info=True)
        
        # Clean up orphaned database entries
        existing_plugins = Plugin.objects.all()
        for plugin in existing_plugins:
            if plugin.name not in discovered_plugins:
                logger.info(f"Removing orphaned plugin from database: {plugin.name}")
                plugin.delete()
        
        logger.info("Plugin auto-discovery completed")

    def load_plugins(self):
        """
        Modified to auto-discover plugins before loading them
        """
        self.auto_discover_plugins()
        plugins = Plugin.objects.filter(enabled=True)
        for plugin in plugins:
            self.plugins[plugin.name] = plugin

    def load_plugin_groups(self):
        # Load enabled plugin groups from the database
        return PluginGroup.objects.filter(enabled=True)

    def load_plugin(self, filepath):
        module_name = os.path.splitext(os.path.basename(filepath))[0]
        spec = importlib.util.spec_from_file_location(module_name, filepath)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        if hasattr(module, "register_plugin"):
            module.register_plugin(self.pm)
            self.plugins[module_name] = module
            logger.info(f"Loaded plugin: {module_name}")

    def unload_plugin(self, plugin_name):
        if plugin_name in self.plugins:
            del self.plugins[plugin_name]
            logger.info(f"Unloaded plugin: {plugin_name}")

    def initialize(self):
        self.pm.hook.initialize()

    def exploit(self):
        self.pm.hook.execute()

    def execute_plugin(self, plugin_name, target=None, parameters=None):
        plugin = self.plugins.get(plugin_name)
        if plugin:
            plugin.execute(target, parameters)
        else:
            print(f"Plugin '{plugin_name}' not found or disabled.")

    def execute_selected_plugins(self, plugin_names, target=None):
        results = {}
        for plugin_name in plugin_names:
            try:
                result = self.execute_plugin(plugin_name, target)
                results[plugin_name] = result
            except ValueError as e:
                logger.warning(f"Error executing plugin '{plugin_name}': {str(e)}")
        return results

    def list_plugins(self):
        """
        Returns a list of all available plugins.
        
        :return: List of plugin names
        :rtype: List[str]
        """
        return list(self.plugins.keys())

    def get_plugin(self, plugin_name):
        logger.debug(f"Attempting to retrieve plugin: {plugin_name}")
        
        if plugin_name in self.plugins:
            plugin_module = self.plugins[plugin_name]
            
            # Find the plugin class that inherits from BasePlugin
            plugin_class = None
            for name, obj in plugin_module.__dict__.items():
                if isinstance(obj, type) and issubclass(obj, BasePlugin) and obj != BasePlugin:
                    plugin_class = obj
                    break
            
            if plugin_class:
                # Instantiate the plugin class
                plugin_instance = plugin_class()
                logger.info(f"Found and instantiated plugin: {plugin_name}")
                return plugin_instance
            else:
                logger.error(f"No valid plugin class found in module {plugin_name}")
                raise ValueError(f"No valid plugin class found in module {plugin_name}")
        else:
            logger.error(f"Plugin {plugin_name} not found")
            raise ValueError(f"Plugin {plugin_name} not found")

    def list_plugin_info(self):
        logger.debug("Starting to list plugin information in ExploitPluginManager.")
        plugin_info = {}
        
        for plugin_name in self.list_plugins():
            logger.debug(f"Processing plugin: {plugin_name}")
            try:
                plugin_instance = self.get_plugin(plugin_name)
                info = plugin_instance.get_info()
                logger.debug(f"Retrieved info for plugin {plugin_name}: {info}")
                plugin_info[plugin_name] = info
                
            except Exception as e:
                logger.error(f"Error processing plugin {plugin_name}: {str(e)}")
                plugin_info[plugin_name] = {"error": str(e)}

        logger.debug(f"Completed listing plugin information. Total plugins: {len(plugin_info)}")
        return plugin_info

    def execute_plugin_group(self, group_name, target=None, parameters=None):
        """
        Execute all plugins in a specified group
        Args:
            group_name: Name of the plugin group to execute
            target: Optional target for the plugins
            parameters: Optional parameters for the plugins
        Returns:
            bool: True if all plugins executed successfully, False otherwise
        """
        try:
            group = PluginGroup.objects.get(name=group_name)
            if not group.enabled:
                logger.warning(f"Plugin group '{group_name}' is disabled")
                return False

            success = True
            plugins = group.plugins.filter(enabled=True)
            
            if not plugins.exists():
                logger.warning(f"No enabled plugins found in group '{group_name}'")
                return False

            logger.info(f"Executing {plugins.count()} plugins from group '{group_name}'")
            
            for plugin in plugins:
                try:
                    logger.info(f"Executing plugin: {plugin.name}")
                    result = self.execute_plugin(plugin.name, target, parameters)
                    if not result:
                        success = False
                        logger.warning(f"Plugin {plugin.name} execution failed")
                except Exception as e:
                    success = False
                    logger.error(f"Error executing plugin {plugin.name}: {str(e)}")

            # Execute child groups if any
            child_relations = PluginGroupTree.objects.filter(parent=group)
            for relation in child_relations:
                if relation.force_exec or success:
                    child_success = self.execute_plugin_group(relation.child.name, target, parameters)
                    if not child_success:
                        success = False

            return success

        except PluginGroup.DoesNotExist:
            logger.error(f"Plugin group '{group_name}' does not exist")
            return False
        except Exception as e:
            logger.error(f"Error executing plugin group: {str(e)}")
            return False
