import os
import importlib.util
import pluggy
import logging
from sat_toolkit.config import EXPLOIT_PLUGINS_DIR

from sat_toolkit.core.exploit_spec import ExploitPluginSpec
logger = logging.getLogger(__name__)

class ExploitPluginManager:
    def __init__(self):
        self.pm = pluggy.PluginManager("exploit_mgr")
        self.pm.add_hookspecs(ExploitPluginSpec)
        self.plugins = {}
        self.load_plugins()

    def load_plugins(self):
        plugin_dir = os.path.join(os.path.dirname(__file__), EXPLOIT_PLUGINS_DIR)
        logger.info(f"Loading exploit plugins from {plugin_dir}")
        for root, _, files in os.walk(plugin_dir):
            for filename in files:
                if filename.endswith(".py") and filename != "__init__.py":
                    self.load_plugin(os.path.join(root, filename))

    def load_plugin(self, filepath):
        module_name = os.path.splitext(os.path.basename(filepath))[0]
        spec = importlib.util.spec_from_file_location(module_name, filepath)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        if hasattr(module, "register_plugin"):
            module.register_plugin(self.pm)
            self.plugins[module_name] = module
            logger.info(f"Loaded plugin: {module_name}")

    def unload_plugin(self, plugin_name):
        if plugin_name in self.plugins:
            del self.plugins[plugin_name]
            logger.info(f"Unloaded plugin: {plugin_name}")

    def initialize(self):
        self.pm.hook.initialize()

    def exploit(self):
        self.pm.hook.execute()

    def execute_plugin(self, plugin_name, target=None):
        logger.info(f"Attempting to execute plugin: {plugin_name}")
        logger.debug(f"Available plugins: {list(self.plugins.keys())}")
        
        if plugin_name in self.plugins:
            logger.info(f"Plugin '{plugin_name}' found")
            plugin_instance = self.plugins[plugin_name]
            logger.debug(f"Plugin instance: {plugin_instance}")
            
            # Get the specific plugin class
            plugin_class = None
            for name, obj in plugin_instance.__dict__.items():
                if isinstance(obj, type) and name.lower().endswith('plugin'):
                    plugin_class = obj
                    break
            
            if plugin_class is None:
                logger.error(f"Could not find plugin class in {plugin_name}")
                return None
            
            # Instantiate the plugin
            plugin = plugin_class()
            
            # Execute the plugin's initialize method if it exists
            if hasattr(plugin, 'initialize'):
                plugin.initialize()
            
            # Execute the plugin's execute method
            if hasattr(plugin, 'execute'):
                result = plugin.execute(target)
                logger.info(f"Execution result: {result}")
                return result
            else:
                logger.error(f"Plugin '{plugin_name}' does not have an execute method")
                return None
        else:
            logger.error(f"Plugin '{plugin_name}' not found")
            raise ValueError(f"Plugin '{plugin_name}' not found.")

    def execute_selected_plugins(self, plugin_names, target=None):
        results = {}
        for plugin_name in plugin_names:
            try:
                result = self.execute_plugin(plugin_name, target)
                results[plugin_name] = result
            except ValueError as e:
                logger.warning(f"Error executing plugin '{plugin_name}': {str(e)}")
        return results

    def list_plugins(self):
        """
        Returns a list of all available plugins.
        
        :return: List of plugin names
        :rtype: List[str]
        """
        return list(self.plugins.keys())

    def get_plugin(self, plugin_name):
        for plugin in self.pm.get_plugins():
            if plugin.__class__.__name__ == plugin_name:
                return plugin
        raise ValueError(f"Plugin {plugin_name} not found")
