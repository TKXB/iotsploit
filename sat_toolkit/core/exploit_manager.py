import os
import importlib.util
import pluggy
import logging
from sat_toolkit.config import EXPLOIT_PLUGINS_DIR
from sat_toolkit.core.base_plugin import BasePlugin


from sat_toolkit.core.exploit_spec import ExploitPluginSpec
logger = logging.getLogger(__name__)

class ExploitPluginManager:
    def __init__(self):
        self.pm = pluggy.PluginManager("exploit_mgr")
        self.pm.add_hookspecs(ExploitPluginSpec)
        self.plugins = {}
        self.load_plugins()

    def load_plugins(self):
        plugin_dir = os.path.join(os.path.dirname(__file__), EXPLOIT_PLUGINS_DIR)
        logger.info(f"Loading exploit plugins from {plugin_dir}")
        for root, _, files in os.walk(plugin_dir):
            for filename in files:
                if filename.endswith(".py") and filename != "__init__.py":
                    self.load_plugin(os.path.join(root, filename))

    def load_plugin(self, filepath):
        module_name = os.path.splitext(os.path.basename(filepath))[0]
        spec = importlib.util.spec_from_file_location(module_name, filepath)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        if hasattr(module, "register_plugin"):
            module.register_plugin(self.pm)
            self.plugins[module_name] = module
            logger.info(f"Loaded plugin: {module_name}")

    def unload_plugin(self, plugin_name):
        if plugin_name in self.plugins:
            del self.plugins[plugin_name]
            logger.info(f"Unloaded plugin: {plugin_name}")

    def initialize(self):
        self.pm.hook.initialize()

    def exploit(self):
        self.pm.hook.execute()

    def execute_plugin(self, plugin_name, target=None):
        logger.info(f"Attempting to execute plugin: {plugin_name}")
        logger.debug(f"Available plugins: {list(self.plugins.keys())}")
        
        if plugin_name in self.plugins:
            logger.info(f"Plugin '{plugin_name}' found")
            plugin_instance = self.plugins[plugin_name]
            logger.debug(f"Plugin instance: {plugin_instance}")
            
            # Get the specific plugin class
            plugin_class = None
            for name, obj in plugin_instance.__dict__.items():
                if isinstance(obj, type) and name.lower().endswith('plugin'):
                    plugin_class = obj
                    break
            
            if plugin_class is None:
                logger.error(f"Could not find plugin class in {plugin_name}")
                return None
            
            # Instantiate the plugin
            plugin = plugin_class()
            
            # Execute the plugin's initialize method if it exists
            if hasattr(plugin, 'initialize'):
                plugin.initialize()
            
            # Execute the plugin's execute method
            if hasattr(plugin, 'execute'):
                result = plugin.execute(target)
                logger.info(f"Execution result: {result}")
                return result
            else:
                logger.error(f"Plugin '{plugin_name}' does not have an execute method")
                return None
        else:
            logger.error(f"Plugin '{plugin_name}' not found")
            raise ValueError(f"Plugin '{plugin_name}' not found.")

    def execute_selected_plugins(self, plugin_names, target=None):
        results = {}
        for plugin_name in plugin_names:
            try:
                result = self.execute_plugin(plugin_name, target)
                results[plugin_name] = result
            except ValueError as e:
                logger.warning(f"Error executing plugin '{plugin_name}': {str(e)}")
        return results

    def list_plugins(self):
        """
        Returns a list of all available plugins.
        
        :return: List of plugin names
        :rtype: List[str]
        """
        return list(self.plugins.keys())

    def get_plugin(self, plugin_name):
        logger.debug(f"Attempting to retrieve plugin: {plugin_name}")
        
        if plugin_name in self.plugins:
            plugin_module = self.plugins[plugin_name]
            
            # Find the plugin class that inherits from BasePlugin
            plugin_class = None
            for name, obj in plugin_module.__dict__.items():
                if isinstance(obj, type) and issubclass(obj, BasePlugin) and obj != BasePlugin:
                    plugin_class = obj
                    break
            
            if plugin_class:
                # Instantiate the plugin class
                plugin_instance = plugin_class()
                logger.info(f"Found and instantiated plugin: {plugin_name}")
                return plugin_instance
            else:
                logger.error(f"No valid plugin class found in module {plugin_name}")
                raise ValueError(f"No valid plugin class found in module {plugin_name}")
        else:
            logger.error(f"Plugin {plugin_name} not found")
            raise ValueError(f"Plugin {plugin_name} not found")

    def list_plugin_info(self):
        logger.debug("Starting to list plugin information in ExploitPluginManager.")
        plugin_info = {}
        
        for plugin_name in self.list_plugins():
            logger.debug(f"Processing plugin: {plugin_name}")
            try:
                plugin_instance = self.get_plugin(plugin_name)
                info = plugin_instance.get_info()
                logger.debug(f"Retrieved info for plugin {plugin_name}: {info}")
                plugin_info[plugin_name] = info
                
            except Exception as e:
                logger.error(f"Error processing plugin {plugin_name}: {str(e)}")
                plugin_info[plugin_name] = {"error": str(e)}

        logger.debug(f"Completed listing plugin information. Total plugins: {len(plugin_info)}")
        return plugin_info
