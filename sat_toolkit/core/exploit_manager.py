import os
import importlib.util
import pluggy
import logging
from sat_toolkit.config import EXPLOIT_PLUGINS_DIR
from sat_toolkit.core.base_plugin import BasePlugin
from sat_toolkit.models.Plugin_Model import Plugin
from sat_toolkit.models.PluginGroup_Model import PluginGroup
from sat_toolkit.models.PluginGroupTree_Model import PluginGroupTree
import glob
from pathlib import Path
import django.db.utils

from sat_toolkit.core.exploit_spec import ExploitPluginSpec
logger = logging.getLogger(__name__)

class ExploitPluginManager:
    def __init__(self):
        self.plugins = {}
        self.pm = pluggy.PluginManager("exploit_mgr")
        self.pm.add_hookspecs(ExploitPluginSpec)
        self.load_plugins()
        self.plugin_groups = self.load_plugin_groups()

    def auto_discover_plugins(self, plugins_dir=EXPLOIT_PLUGINS_DIR):
        """
        Automatically discover and register plugins from the plugins directory.
        Also removes database entries for plugins that no longer exist.
        """
        logger.debug(f"Starting plugin auto-discovery in {plugins_dir}")
        
        # Keep track of found plugins
        discovered_plugins = set()
        
        try:
            # Find all Python files recursively
            plugin_files = glob.glob(f"{plugins_dir}/**/*.py", recursive=True)
            
            for plugin_file in plugin_files:
                try:
                    # Skip __init__.py files
                    if "__init__.py" in plugin_file:
                        continue
                    
                    # Get module path relative to project root
                    rel_path = os.path.relpath(plugin_file)
                    # Convert path to module notation, but keep the full path including the filename
                    module_path = rel_path.replace('/', '.').replace('\\', '.').replace('.py', '')
                    
                    # Load the module to inspect it
                    spec = importlib.util.spec_from_file_location(module_path, plugin_file)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    
                    # Find plugin class that inherits from BasePlugin
                    plugin_class = None
                    for name, obj in module.__dict__.items():
                        if isinstance(obj, type) and issubclass(obj, BasePlugin) and obj != BasePlugin:
                            plugin_class = obj
                            break
                    
                    if plugin_class:
                        # Instantiate to get plugin info
                        plugin_instance = plugin_class()
                        plugin_info = plugin_instance.get_info()
                        
                        if plugin_info:
                            plugin_name = plugin_info.get('Name', plugin_class.__name__)
                            try:
                                # Create or update plugin in database
                                plugin, created = Plugin.objects.update_or_create(
                                    name=plugin_name,
                                    defaults={
                                        'description': plugin_info.get('Description', ''),
                                        'enabled': True,
                                        'module_path': f"{module_path}.{plugin_class.__name__}",  # Include class name in module path
                                        'license': plugin_info.get('License', ''),
                                        'author': plugin_info.get('Author', ''),
                                        'parameters': str(plugin_info.get('Parameters', {}))
                                    }
                                )
                                
                                # Add to discovered plugins set
                                discovered_plugins.add(plugin_name)
                                
                                action = "Created" if created else "Updated"
                                logger.info(f"{action} plugin in database: {plugin_name}")
                            except django.db.utils.OperationalError:
                                logger.error("Database not initialized. Please run migrations first: python manage.py migrate")
                                return
                            except Exception as e:
                                logger.error(f"Error updating plugin in database: {str(e)}")
                
                except Exception as e:
                    logger.error(f"Error processing plugin file {plugin_file}: {str(e)}")
                    logger.debug("Detailed error:", exc_info=True)
                    continue  # Continue with next plugin even if one fails
            
            try:
                # Clean up orphaned database entries
                existing_plugins = Plugin.objects.all()
                for plugin in existing_plugins:
                    if plugin.name not in discovered_plugins:
                        logger.info(f"Removing orphaned plugin from database: {plugin.name}")
                        plugin.delete()
            except django.db.utils.OperationalError:
                logger.error("Database not initialized. Please run migrations first: python manage.py migrate")
                return
            except Exception as e:
                logger.error(f"Error cleaning up orphaned plugins: {str(e)}")
            
            logger.info("Plugin auto-discovery completed")
            
        except Exception as e:
            logger.error(f"Error during plugin discovery: {str(e)}")
            logger.debug("Detailed error:", exc_info=True)

    def load_plugins(self):
        """
        Modified to auto-discover plugins and register them with the plugin manager
        """
        self.auto_discover_plugins()
        plugins = Plugin.objects.filter(enabled=True)
        for plugin in plugins:
            self.plugins[plugin.name] = plugin
            # Load and register each plugin
            try:
                self.get_plugin(plugin.name)
            except Exception as e:
                logger.error(f"Failed to load plugin {plugin.name}: {str(e)}")

    def load_plugin_groups(self):
        # Load enabled plugin groups from the database
        return PluginGroup.objects.filter(enabled=True)

    def load_plugin(self, filepath):
        module_name = os.path.splitext(os.path.basename(filepath))[0]
        spec = importlib.util.spec_from_file_location(module_name, filepath)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # Look for plugin class that inherits from BasePlugin
        for name, obj in module.__dict__.items():
            if isinstance(obj, type) and issubclass(obj, BasePlugin) and obj != BasePlugin:
                plugin_instance = obj()
                self.pm.register(plugin_instance)
                self.plugins[module_name] = module
                logger.info(f"Loaded plugin: {module_name}")
                break

    def unload_plugin(self, plugin_name):
        if plugin_name in self.plugins:
            del self.plugins[plugin_name]
            logger.info(f"Unloaded plugin: {plugin_name}")

    def initialize(self):
        self.pm.hook.initialize()

    def exploit(self):
        self.pm.hook.execute()

    async def execute_plugin_async(self, plugin_name, target=None, parameters=None):
        """Execute a plugin asynchronously if it supports it, otherwise fall back to sync execution"""
        plugin = self.plugins.get(plugin_name)
        if not plugin:
            logger.warning(f"Plugin '{plugin_name}' not found or disabled.")
            return None

        plugin_instance = self.get_plugin(plugin_name)
        
        # Check if plugin supports async execution
        if hasattr(plugin_instance, 'execute_async'):
            result = await plugin_instance.execute_async(target, parameters)
        else:
            # Fall back to synchronous execution
            result = plugin_instance.execute(target, parameters)
        
        return result

    def execute_plugin(self, plugin_name, target=None, parameters=None):
        """
        Execute a plugin with the given parameters. This method handles both synchronous
        and asynchronous execution based on plugin capabilities.
        
        Args:
            plugin_name (str): Name of the plugin to execute
            target (object, optional): Target for the plugin execution
            parameters (dict, optional): Parameters for plugin execution
            
        Returns:
            For sync execution: The result of plugin execution
            For async execution: A dict containing task information
        """
        plugin = self.plugins.get(plugin_name)
        if not plugin:
            logger.warning(f"Plugin '{plugin_name}' not found or disabled.")
            return None

        try:
            plugin_instance = self.get_plugin(plugin_name)
            parameters = parameters or {}
            
            # Determine if we should execute asynchronously
            should_execute_async = (
                hasattr(plugin_instance, 'execute_async') or  # Plugin supports async
                parameters.get('duration', 0) > 5 or          # Long running task
                parameters.get('stream', False) or            # Streaming data
                parameters.get('async', False)                # Explicitly requested async
            )

            if should_execute_async:
                # Import here to avoid circular imports
                from sat_toolkit.tasks import execute_plugin_task
                
                logger.info(f"Starting async execution for plugin: {plugin_name}")
                
                # Convert target to serializable form if needed
                if hasattr(target, 'get_info'):
                    serializable_target = target.get_info()
                else:
                    serializable_target = target
                
                # Start Celery task
                task = execute_plugin_task.delay(
                    plugin_name,
                    target=serializable_target,
                    parameters=parameters
                )
                
                return {
                    'execution_type': 'async',
                    'task_id': task.id
                }
            else:
                # Execute synchronously
                logger.info(f"Executing plugin synchronously: {plugin_name}")
                result = plugin_instance.execute(target, parameters)
                
                # Format the result
                if hasattr(result, 'success'):
                    return {
                        'success': result.success,
                        'message': result.message if hasattr(result, 'message') else str(result),
                        'data': result.data if hasattr(result, 'data') else None
                    }
                else:
                    return {
                        'message': str(result)
                    }
                
        except Exception as e:
            logger.error(f"Error executing plugin {plugin_name}: {str(e)}")
            raise ValueError(f"Error executing plugin {plugin_name}: {str(e)}")

    def execute_selected_plugins(self, plugin_names, target=None):
        results = {}
        for plugin_name in plugin_names:
            try:
                result = self.execute_plugin(plugin_name, target)
                results[plugin_name] = result
            except ValueError as e:
                logger.warning(f"Error executing plugin '{plugin_name}': {str(e)}")
        return results

    def list_plugins(self):
        """
        Returns a list of all available plugins.
        
        :return: List of plugin names
        :rtype: List[str]
        """
        return list(self.plugins.keys())

    def get_plugin(self, plugin_name):
        logger.debug(f"Attempting to retrieve plugin: {plugin_name}")
        
        if plugin_name in self.plugins:
            plugin_db = self.plugins[plugin_name]  # This is now a Plugin model instance
            
            try:
                # Split the module path to get module path and class name
                module_path = plugin_db.module_path
                module_parts = module_path.rsplit('.', 1)
                if len(module_parts) != 2:
                    raise ValueError(f"Invalid module path format: {module_path}")
                    
                module_name, class_name = module_parts
                
                # Import the module
                spec = importlib.util.find_spec(module_name)
                if spec is None:
                    raise ImportError(f"Could not find module: {module_name}")
                    
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Get the plugin class
                if hasattr(module, class_name):
                    plugin_class = getattr(module, class_name)
                    if issubclass(plugin_class, BasePlugin):
                        plugin_instance = plugin_class()
                        # Register the plugin instance with the plugin manager
                        self.pm.register(plugin_instance)
                        logger.info(f"Found and registered plugin: {plugin_name}")
                        return plugin_instance
                        
                logger.error(f"No valid plugin class found in module {plugin_name}")
                raise ValueError(f"No valid plugin class found in module {plugin_name}")
                
            except Exception as e:
                logger.error(f"Error loading plugin {plugin_name}: {str(e)}")
                raise ValueError(f"Error loading plugin {plugin_name}: {str(e)}")
        else:
            logger.error(f"Plugin {plugin_name} not found")
            raise ValueError(f"Plugin {plugin_name} not found")

    def list_plugin_info(self):
        logger.debug("Starting to list plugin information in ExploitPluginManager.")
        plugin_info = {}
        
        for plugin_name in self.list_plugins():
            logger.debug(f"Processing plugin: {plugin_name}")
            try:
                plugin_instance = self.get_plugin(plugin_name)
                info = plugin_instance.get_info()
                logger.debug(f"Retrieved info for plugin {plugin_name}: {info}")
                plugin_info[plugin_name] = info
                
            except Exception as e:
                logger.error(f"Error processing plugin {plugin_name}: {str(e)}")
                plugin_info[plugin_name] = {"error": str(e)}

        logger.debug(f"Completed listing plugin information. Total plugins: {len(plugin_info)}")
        return plugin_info

    def execute_plugin_group(self, group_name, target=None, parameters=None):
        """
        Execute all plugins in a specified group
        Args:
            group_name: Name of the plugin group to execute
            target: Optional target for the plugins
            parameters: Optional parameters for the plugins
        Returns:
            bool: True if all plugins executed successfully, False otherwise
        """
        try:
            group = PluginGroup.objects.get(name=group_name)
            if not group.enabled:
                logger.warning(f"Plugin group '{group_name}' is disabled")
                return False

            success = True
            plugins = group.plugins.filter(enabled=True)
            
            if not plugins.exists():
                logger.warning(f"No enabled plugins found in group '{group_name}'")
                return False

            logger.info(f"Executing {plugins.count()} plugins from group '{group_name}'")
            
            for plugin in plugins:
                try:
                    logger.info(f"Executing plugin: {plugin.name}")
                    result = self.execute_plugin(plugin.name, target, parameters)
                    if not result:
                        success = False
                        logger.warning(f"Plugin {plugin.name} execution failed")
                except Exception as e:
                    success = False
                    logger.error(f"Error executing plugin {plugin.name}: {str(e)}")

            # Execute child groups if any
            child_relations = PluginGroupTree.objects.filter(parent=group)
            for relation in child_relations:
                if relation.force_exec or success:
                    child_success = self.execute_plugin_group(relation.child.name, target, parameters)
                    if not child_success:
                        success = False

            return success

        except PluginGroup.DoesNotExist:
            logger.error(f"Plugin group '{group_name}' does not exist")
            return False
        except Exception as e:
            logger.error(f"Error executing plugin group: {str(e)}")
            return False
