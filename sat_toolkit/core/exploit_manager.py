import os
import importlib.util
import pluggy
from sat_toolkit.config import EXPLOIT_PLUGINS_DIR
from sat_toolkit.core.base_plugin import BasePlugin
from sat_toolkit.models.Plugin_Model import Plugin
from sat_toolkit.models.PluginGroup_Model import PluginGroup
from sat_toolkit.models.PluginGroupTree_Model import PluginGroupTree
import glob
from pathlib import Path
import django.db.utils
from sat_toolkit.tools.xlogger import xlog
from typing import Optional

from sat_toolkit.core.exploit_spec import ExploitPluginSpec

class ExploitPluginManager:
    def __init__(self):
        self.plugins = {}  # Will store plugin instances
        self.pm = pluggy.PluginManager("exploit_mgr")
        self.pm.add_hookspecs(ExploitPluginSpec)
        self.load_plugins()
        self.plugin_groups = self.load_plugin_groups()
        import atexit
        atexit.register(self.cleanup_all_plugins)

    def auto_discover_plugins(self, plugins_dir=EXPLOIT_PLUGINS_DIR):
        """
        Automatically discover and register plugins from the plugins directory.
        Also removes database entries for plugins that no longer exist.
        """
        xlog.debug(f"Starting plugin auto-discovery in {plugins_dir}", "exploit_mgr")
        
        # Keep track of found plugins
        discovered_plugins = set()
        
        try:
            # Find all Python files recursively
            plugin_files = glob.glob(f"{plugins_dir}/**/*.py", recursive=True)
            
            for plugin_file in plugin_files:
                try:
                    # Skip __init__.py files
                    if "__init__.py" in plugin_file:
                        continue
                    
                    # Get module path relative to project root
                    rel_path = os.path.relpath(plugin_file)
                    # Convert path to module notation
                    module_path = rel_path.replace('/', '.').replace('\\', '.').replace('.py', '')
                    
                    # Load the module to inspect it
                    spec = importlib.util.spec_from_file_location(module_path, plugin_file)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    
                    # Find plugin class that inherits from BasePlugin
                    plugin_class = None
                    for name, obj in module.__dict__.items():
                        if isinstance(obj, type) and issubclass(obj, BasePlugin) and obj != BasePlugin:
                            plugin_class = obj
                            break
                    
                    if plugin_class:
                        # Get plugin info
                        plugin_instance = plugin_class()
                        plugin_info = plugin_instance.get_info()
                        
                        if plugin_info:
                            plugin_name = plugin_info.get('Name', plugin_class.__name__)
                            try:
                                # Create or update plugin in database
                                plugin, created = Plugin.objects.update_or_create(
                                    name=plugin_name,
                                    defaults={
                                        'description': plugin_info.get('Description', ''),
                                        'enabled': True,
                                        'module_path': f"{module_path}.{plugin_class.__name__}",
                                        'license': plugin_info.get('License', ''),
                                        'author': plugin_info.get('Author', ''),
                                        'parameters': str(plugin_info.get('Parameters', {}))
                                    }
                                )
                                
                                discovered_plugins.add(plugin_name)
                                action = "Created" if created else "Updated"
                                xlog.info(f"{action} plugin in database: {plugin_name}", "exploit_mgr")
                                
                            except django.db.utils.OperationalError:
                                xlog.error("Database not initialized. Please run migrations first.", "exploit_mgr")
                                return
                            except Exception as e:
                                xlog.error(f"Error updating plugin in database: {str(e)}", "exploit_mgr")
                
                except Exception as e:
                    xlog.error(f"Error processing plugin file {plugin_file}: {str(e)}", "exploit_mgr")
                    continue
            
            # Clean up orphaned database entries
            try:
                existing_plugins = Plugin.objects.all()
                for plugin in existing_plugins:
                    if plugin.name not in discovered_plugins:
                        xlog.info(f"Removing orphaned plugin from database: {plugin.name}", "exploit_mgr")
                        plugin.delete()
            except Exception as e:
                xlog.error(f"Error cleaning up orphaned plugins: {str(e)}", "exploit_mgr")
            
            xlog.info("Plugin auto-discovery completed", "exploit_mgr")
            
        except Exception as e:
            xlog.error(f"Error during plugin discovery: {str(e)}", "exploit_mgr")

    def load_plugins(self):
        """
        Load and initialize all plugins
        """
        self.auto_discover_plugins()
        plugins = Plugin.objects.filter(enabled=True)
        for plugin_db in plugins:
            try:
                # Split the module path to get module path and class name
                module_path = plugin_db.module_path
                module_parts = module_path.rsplit('.', 1)
                if len(module_parts) != 2:
                    raise ValueError(f"Invalid module path format: {module_path}")
                    
                module_name, class_name = module_parts
                
                # Import the module
                spec = importlib.util.find_spec(module_name)
                if spec is None:
                    raise ImportError(f"Could not find module: {module_name}")
                    
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Get the plugin class
                if hasattr(module, class_name):
                    plugin_class = getattr(module, class_name)
                    if issubclass(plugin_class, BasePlugin):
                        plugin_instance = plugin_class()
                        self.pm.register(plugin_instance)
                        self.plugins[plugin_db.name] = plugin_instance
                        xlog.info(f"Loaded and registered plugin: {plugin_db.name}", "exploit_mgr")
                        
            except Exception as e:
                xlog.error(f"Failed to load plugin {plugin_db.name}: {str(e)}", "exploit_mgr")

    def load_plugin_groups(self):
        # Load enabled plugin groups from the database
        return PluginGroup.objects.filter(enabled=True)

    def initialize(self):
        self.pm.hook.initialize()

    def exploit(self):
        self.pm.hook.execute()

    async def execute_plugin_async(self, plugin_name, target=None, parameters=None):
        """Execute a plugin asynchronously if it supports it, otherwise fall back to sync execution"""
        plugin_instance = self.plugins.get(plugin_name)
        if not plugin_instance:
            xlog.warning(f"Plugin '{plugin_name}' not found or disabled.", "exploit_mgr")
            return None

        # Check if plugin supports async execution
        if hasattr(plugin_instance, 'execute_async'):
            result = await plugin_instance.execute_async(target, parameters)
        else:
            # Fall back to synchronous execution
            result = plugin_instance.execute(target, parameters)
        
        return result

    def execute_plugin(self, plugin_name, target=None, parameters=None):
        """
        Execute a plugin with the given parameters.
        """
        plugin_instance = self.plugins.get(plugin_name)
        if not plugin_instance:
            xlog.warning(f"Plugin '{plugin_name}' not found or disabled.", "exploit_mgr")
            return None

        try:
            parameters = parameters or {}
            
            # Determine if we should execute asynchronously
            should_execute_async = (
                hasattr(plugin_instance, 'execute_async') or  # Plugin supports async
                parameters.get('duration', 0) > 5 or          # Long running task
                parameters.get('stream', False) or            # Streaming data
                parameters.get('async', False)                # Explicitly requested async
            )

            if should_execute_async:
                # Import here to avoid circular imports
                from sat_toolkit.tasks import execute_plugin_task
                
                xlog.info(f"Starting async execution for plugin: {plugin_name}", "exploit_mgr")
                
                # Convert target to serializable form if needed
                if hasattr(target, 'get_info'):
                    serializable_target = target.get_info()
                else:
                    serializable_target = target
                
                # Start Celery task
                task = execute_plugin_task.delay(
                    plugin_name,
                    target=serializable_target,
                    parameters=parameters
                )
                
                return {
                    'execution_type': 'async',
                    'task_id': task.id
                }
            else:
                # Execute synchronously
                xlog.info(f"Executing plugin synchronously: {plugin_name}", "exploit_mgr")
                result = plugin_instance.execute(target, parameters)
                
                # Format the result
                if hasattr(result, 'success'):
                    return {
                        'success': result.success,
                        'message': result.message if hasattr(result, 'message') else str(result),
                        'data': result.data if hasattr(result, 'data') else None
                    }
                else:
                    return {
                        'message': str(result)
                    }
                
        except Exception as e:
            xlog.error(f"Error executing plugin {plugin_name}: {str(e)}", "exploit_mgr")
            raise ValueError(f"Error executing plugin {plugin_name}: {str(e)}")

    def execute_selected_plugins(self, plugin_names, target=None):
        results = {}
        for plugin_name in plugin_names:
            try:
                result = self.execute_plugin(plugin_name, target)
                results[plugin_name] = result
            except ValueError as e:
                xlog.warning(f"Error executing plugin '{plugin_name}': {str(e)}", "exploit_mgr")
        return results

    def list_plugins(self):
        """
        Returns a list of all available plugins.
        """
        return list(self.plugins.keys())

    def list_plugin_info(self):
        xlog.debug("Starting to list plugin information", "exploit_mgr")
        plugin_info = {}
        
        for plugin_name, plugin_instance in self.plugins.items():
            xlog.debug(f"Processing plugin: {plugin_name}", "exploit_mgr")
            try:
                info = plugin_instance.get_info()
                xlog.debug(f"Retrieved info for plugin {plugin_name}: {info}", "exploit_mgr")
                plugin_info[plugin_name] = info
                
            except Exception as e:
                xlog.error(f"Error processing plugin {plugin_name}: {str(e)}", "exploit_mgr")
                plugin_info[plugin_name] = {"error": str(e)}

        xlog.debug(f"Completed listing plugin information. Total plugins: {len(plugin_info)}", "exploit_mgr")
        return plugin_info

    def get_plugin(self, plugin_name: str) -> Optional[BasePlugin]:
        """
        Get a plugin instance by name.
        
        Args:
            plugin_name (str): The name of the plugin to retrieve
            
        Returns:
            Optional[BasePlugin]: The plugin instance if found, None otherwise
        """
        plugin_instance = self.plugins.get(plugin_name)
        if not plugin_instance:
            xlog.warning(f"Plugin '{plugin_name}' not found or disabled.", "exploit_mgr")
            return None
        return plugin_instance

    def execute_plugin_group(self, group_name, target=None, parameters=None, force_exec=True):
        """
        Execute the named plugin‑group *including* its nested groups and plugins.

        The actual ordered execution and failure‑handling logic lives inside
        PluginGroup.execute(), which honours:
            • PluginSequence.sequence / ignore_fail
            • PluginGroupTree.sequence / ignore_fail / force_exec
        """
        try:
            group = PluginGroup.objects.get(name=group_name)
        except PluginGroup.DoesNotExist:
            xlog.error(f"Plugin group '{group_name}' does not exist", "exploit_mgr")
            return False

        # obey “enabled” flag unless overridden
        if not group.enabled and not force_exec:
            xlog.warning(f"Plugin group '{group_name}' is disabled", "exploit_mgr")
            return False

        xlog.info(f"Executing plugin group '{group_name}'", "exploit_mgr")
        ok = group.execute(target, parameters, force_exec)

        if ok:
            xlog.info(f"Plugin group '{group_name}' executed successfully", "exploit_mgr")
        else:
            xlog.warning(f"Plugin group '{group_name}' finished with failures", "exploit_mgr")
        return ok

    def cleanup_all_plugins(self):
        """
        Cleanup all registered plugins. This method is called automatically on program exit
        and can also be called manually when needed.
        """
        xlog.info("Starting cleanup of all plugins", "exploit_mgr")
        try:
            # Log registered plugins before cleanup using class names instead of name attribute
            registered_plugins = [p.__class__.__name__ for p in self.pm.get_plugins()]
            xlog.info(f"Registered plugins for cleanup: {registered_plugins}", "exploit_mgr")
            
            # Call cleanup hook on all registered plugins
            self.pm.hook.cleanup()
            
            # Clear plugin references
            self.plugins.clear()
            xlog.info("Successfully cleaned up all plugins", "exploit_mgr")
        except Exception as e:
            xlog.error(f"Error during plugin cleanup: {str(e)}", "exploit_mgr")

    def __del__(self):
        """
        Destructor to ensure cleanup is called when the manager is destroyed
        """
        try:
            self.cleanup_all_plugins()
        except Exception as e:
            xlog.error(f"Error during ExploitPluginManager cleanup: {str(e)}", "exploit_mgr")

    def reload_plugin(self, plugin_name):
        """
        Reload a plugin after its code has been modified.
        
        Args:
            plugin_name (str): The name of the plugin to reload
            
        Returns:
            bool: True if the plugin was successfully reloaded, False otherwise
        """
        try:
            # Get the plugin from the database
            try:
                plugin_db = Plugin.objects.get(name=plugin_name)
            except Plugin.DoesNotExist:
                xlog.error(f"Plugin {plugin_name} not found in database", "exploit_mgr")
                return False
            
            # Get the module path
            module_path = plugin_db.module_path
            if not module_path:
                xlog.error(f"Module path not found for plugin {plugin_name}", "exploit_mgr")
                return False
            
            # Split the module path to get the module and class name
            module_name, class_name = module_path.rsplit('.', 1)
            
            # Reload the module
            try:
                # First, unregister the existing plugin
                if plugin_name in self.plugins:
                    self.pm.unregister(self.plugins[plugin_name])
                    del self.plugins[plugin_name]
                
                # Reload the module
                module = importlib.import_module(module_name)
                importlib.reload(module)
                
                # Get the plugin class
                plugin_class = getattr(module, class_name)
                
                # Create a new instance of the plugin
                plugin_instance = plugin_class()
                
                # Register the plugin
                self.pm.register(plugin_instance)
                self.plugins[plugin_name] = plugin_instance
                
                xlog.info(f"Successfully reloaded plugin: {plugin_name}", "exploit_mgr")
                return True
            except Exception as e:
                xlog.error(f"Error reloading plugin {plugin_name}: {str(e)}", "exploit_mgr")
                return False
        except Exception as e:
            xlog.error(f"Error in reload_plugin: {str(e)}", "exploit_mgr")
            return False
